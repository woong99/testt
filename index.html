<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
    <link rel="stylesheet" href="./index.css" />
  </head>
  <body>
    <h1>파티션</h1>
    <p>디스크는 다시 몇 개의 파티션으로 구별하여 사용</p>
    <p>각각 독립적인 가상 디스크처럼 사용</p>
    <p>여러 개의 디스크들을 합쳐서 하나의 큰 파티션으로 처리 가능</p>
    <p>파일 목록 영역</p>
    <p>- 파일들의 목록을 기록</p>
    <p>- 각 파일에 대해 속성들을 기록</p>
    <p>파일 데이터 영역</p>
    <p>- 파일들의 데이터를 기록</p>
    <p>- 사용자가 기록하고자 하는 각 파일별 데이터를 기록</i>
    <h1>파일</h1>
    <p>사용자의 정보를 저장하는 독립적 단위로서 논리적으로 연속된 하나의 저장 공간</p>
    <p>예전에는 일정한 형식을 갖춘 자료인 레코드들의 연속적인 집합으로 정의</p>
    <p>유닉스 보편화 후 단순히 바이트 단위의 자료들의 연속적인 집합으로 정의</p>
    <h1>파일 시스템</h1>
    <p>
      저장 매체인 디스크 상에 체계적으로 파일들을 기록하고 관리하는 방식을 총체적으로 지칭하는 것
    </p>
    <p>
      디스크 상에 파일 목록과 파일의 데이터들을 배치하는 방식, 파일에 대한 생성/삭제/읽기/쓰기 등의
      작업을 처리하는 방식을 모두 포함
    </p>
    <p>하나의 파티션에는 한가지 형식의 파일시스템을 적용</p>
    <h1>순차접근</h1>
    <p>읽기나 쓰기 작업이 파일의 첫 바이트부터 순차적으로 이루어짐</p>
    <p>다음의 읽기/쓰기를 위한 위치가 운영체제 내부에 기록</p>
    <h1>직접접근</h1>
    <p>읽기나 쓰기 작업 요청시에 작업 위치를 동시에 지정</p>
    <h1>접근권한 검사</h1>
    <p>파일 소유자별 보호</p>
    <p>- 프로세스가 파일 접근을 위한 시스템 콜 함수를 호출했을 떄 이 프로세스의 사용자 번호와 이 파일의 소유자 번호가 일치하는지 여부를 검사</p>
    <p>파일의 소유 그룹별 보호</p>
    <p>- 이 프로세스의 사용자가 소속된 그룹 번호 중 하나와 이 파일의 소유 그룹 번호가 일치하는지 여부를 검사</p>
    <h1>접근 권한 표현 방법</h1>
    <p>파일들뿐만 아니라 입출력 장치들이나 논리적인 객체들에 대하여 접근 허용 여부에 관한 일반적인 표현 방법</p>
    <p>접근 주체인 도메인들과 접근 대상인 객체들에 대하여 접근 행렬로 표시</p>
    <h1>객체별 접근 목록</h1>
    <p>각 객체별로 도메인들에 대한 권한들을 목록으로 표시</p>
    <h1>도메인별 권한 목록</h1>
    <p>각 도메인별로 접근이 가능한 객체들에 대한 권한들의 목록을 표시</p>
    <h1>객체별 접근 목록과 도메인별 권한목록의 비교</h1>
    <p>유닉스 계열의 운영체제들은 모두 객체별 접근 목록</p>
    <p>- 세 개의 도메인만 기록하도록 제한</p>
    <p>도메인보다 객체의 개수가 월등히 많음</p>
    <p>도메인별 권한 목록의 길이가 객체별 접근 목록의 길이에 비해 아주 길고</p>
    <p>목록에서 검색이나 추가/삭제를 위해서는 훨씬 많은 시간이 소모</p>
    <h1>파일의 생성</h1>
    <p>사용되지 않고 있는 파일제어블록을 찾아서 생성될 파일의 각종 속성 정보들을 기록</p>
    <p>이름 영역과 보호모드 영역은 생성을 요청한 이름과 보호모드로 기록</p>
    <p>파일의 소유자와 소유그룹은 생성을 요청한 프로세스의 사용자와 사용자그룹의 번호로 기록</p>
    <p>이미 생성된 파일은 파일 속성을 수정하는 작업을 통하여 소유자, 소유그룹 및 보호 모드를 변경 가능</p>
    <p>파일의 크기는 0으로 기록</p>
    <h1>파일열기와 접근권한 검사</h1>
    <p>파일열기 요청을 받으면 운영체제는 파일목록 영역의 파일제어블록들을 검사하여 이름이 일치하는 것을 찾은 다음 그 속성 정보들을 활용하여 접근 권한이 있는지를 검사</p>
    <p>현재 파일열기를 요청한 정보로서 읽기나 쓰기의 여부, 프로세스의 사용자 번호 및 사용자 그룹 번호를 사용</p>
    <p>파일제어블록의 정보로서 소유자 번호, 소유그룹 번호 및 보호모드 정보를 사용하여 요청한 작업의 허용 여부를 판단</p>
    <h1>디렉터리 구조</h1>
    <p>평면 구조</p>
    <p>- 하나의 파티션에 하나의 디렉터리만 존재</p>
    <p>- 파일목록 영역에 파일제어블록들을 배열 형태로 배치</p>
    <p>트리 구조</p>
    <p>- 하나의 파티션에 여러 개의 디렉터리들이 존재</p>
    <p>- 상하관계 존재</p>
    <p>- 파일들을 특성별로 별도의 디렉터리에 저장함으로써 많은 개수 파일들을 체계적으로 관리 가능</p>
    <p>임의 구조</p>
    <p>임의의 그래프 형태로 관계 설정</p>
    <h1>트리 구조의 파일제어블록</h1>
    <p>디스크의 용량이 커지면서 대부분의 운영체제에서 트리구조의 파일시스템을 지원</p>
    <p>평면 구조</p>
    <p>- FCB에 파일이름을 포함하도록 하여 원하는 파일을 찾을 수 있음</p>
    <p>트리 구조</p>
    <p>- FCB에 파일이름을 포함하지 않음</p>
    <p>- 디렉터리의 데이터 블록에 하부 파일이나 디렉터리들의 이름을 등록</p>
    <p>- <이름, 고유번호> 형태의 쌍으로 기록 </p>
    <p>- 고유번호는 FCB들의 배열에서 몇 번째 것인지의 인덱스 번호를 활용</p>
    <h1>하드링크/심볼릭링크</h1>
    <p>하드링크나 심볼릭링크를 이용하여 제한적으로 비순환 그래프나 임의의 그래프 형태와 유사하게 사용 가능</p>
    <p>링크 기능은 임의의 디렉터리나 파일을 다른 디렉터리에 중복하여 등록 가능하게 해줌</p>
    <p>하드 링크</p>
    <p>- 동일한 파일제어블록에 비해 여러 개의 파일경로를 가질 수 있음</p>
    <p>- 동일한 파일시스템 내에서만 복수의 파일 경로들을 가질 수 있음</p>
    <p>심볼릭 링크</p>
    <p>- 별도의 파일제어블록을 할당</p>
    <p>- 단지 대상의 이름만 다른 것으로 바꿔서 사용</p>
    <h1>댕글링 포인터</h1>
    <p>하드링크는 여러 이름 중에서 일부를 삭제해도 나머지의 이름으로 파일이 유지되는데, 심볼릭 링크의 경우 대상 파일을 삭제하면 실제로는 존재하지 않는 파일로의 링크를 가짐</p>
    <h1>블록의 크기</h1>
    <p>디스크 입출력의 최소 단위는 512바이트 크기의 섹터</p>
    <p>파일에 저장 공간을 할당할 때 몇 개의 연속된 섹터들을 한 묶음으로 하는 블록 단위로 처리</p>
    <h1>유닉스의 다단계 인덱스</h1>
    <p>인덱스 블록 할당 방식을 변형하여 사용</p>
    <p>파일들의 변경이 빈번하고 임의 위치 접근 작업도 빈번하게 발생</p>
    <h1>파일 크기 한계</h1>
    <p>파일제어블록의 인덱스 테이블에 15개의 블록 기록</p>
    <p>12개까지는 해당 데이터 블록의 번호를 기록</p>
    <p>13번째 항목(1차 간접 항목)에는 인덱스 테이블을 기록한 블록의 번호를 기록</p>
    <p>- 이 블록으로 실제 데이터 블록들의 인덱스를 찾음</p>
    <p>- 한 블록 크기가 1024바이트, 블록 번호가 4바이트이면 256개의 인덱스 기록 가능</p>
    <p>14번째 항목(2차 간접 블록)</p>
    <p>- 256 ^ 2 개의 인덱스 기록</p>
    <p>15번째 항목(3차 간접 블록)</p>
    <p>- 256 ^ 3 개의 인덱스 기록</p>
    <h1>처리 속도</h1>
    <p>다단으로 갈수록 데이터 블록 번호를 확인하는데 더 많은 시간이 소요</p>
    <p>12블록 이내의 것들은 12번째 블록까지만 사용하면 되기 때문에 속도 저하 없음</p>
    <h1>윈도즈 FAT16/32</h1>
    <p>FAT는 파티션의 시작 부분에 일정한 크기로 존재</p>
    <p>블록 간의 연결에 대한 정보는 데이터블록이 아니라 FAT에 모아서 관리</p>
    <p>파티션 내의 모든 데이터 블록들의 번호를 기록할 수 있는 배열 형태</p>
    <p>FAT16은 블록번호를 16비트로 처리</p>
    <p>FAT32는 큰 디스크 용량을 처리하기 위해서 블록 번호를 32비트로 처리</p>
    <p>FAT의 내용 전체를 항상 메인 메모리에 유지하는 것이 필요</p>
    <h1>빈 블록 목록 관리</h1>
    <p>연결된 블록 할당</p>
    <p>- 파일의 데이터 블록들을 위한 연결된 블록 할당 방식을 빈 블록들을 위해 그대로 적용</p>
    <p>비트맵 할당</p>
    <p>- 파티션의 앞부분에 비트맵 영역을 따로 두고, 사용 여부를 1비트씩의 정보로 기록</p>
    <p>- 원하는 크기의 연속된 빈 블록들의 영역을 효율적으로 사용</p>
    <h1>파티션 구성</h1>
    <p>하나의 파티션은 파일목록 블록 영역과 데이터 블록 영역 외에 부트 블록과 슈퍼 블록이 사용</p>
    <p>파티션의 첫 블록을 부트 블록</p>
    <p>다음 한 블록을 슈퍼 블록</p>
    <p>다음 일정한 크기의 파일목록 영역</p>
    <p>나머지가 파일데이터 영역</p>
    <h1>부트 블록</h1>
    <p>부팅 과정에서만 사용되는 부분</p>
    <p>부팅을 위한 프로그램이 들어 있음</p>
    <p>부트 디스크일 경우에만 실제로 사용</p>
    <h1>슈퍼 블록</h1>
    <p>파일시스템에 관련된 주요 정보들을 기록하는 영역으로 사용</p>
    <p>파일시스템의 종류를 구분할 수 있는 고유 숫자</p>
    <p>파티션 이름,크기</p>
    <p>파일 개수, 파일 목록 영역의 빈 파일제어블록들의 개수</p>
    <p>빈 파일제어블록들의 목록</p>
    <p>파일데이터 영역의 빈 데이터 블록들의 개수</p>
    <p>빈 데이터 블록들의 목록 및 물리적으로 손상이 있는 블록들의 목록</p>
    <h1>파일시스템 마운트</h1>
    <p>특정 파티션을 그 속의 파일들에 대하여 사용자가 접근할 수 있도록 등록하는 절차</p>
    <p>유닉스에서는 특정 파티션을 이미 마운트된 파티션들의 임의의 디렉터리에 연결</p>
    <p>윈도우에서는 무조건 '내컴퓨터' 폴더에 지정된 이르으로 자동으로 마운트</p>
    <p>마운트를 위한 절차</p>
    <p>1. 지정된 파티션에 대해 실제 존재하는 지를 검사</p>
    <p>2. 슈퍼 블록 및 파일목록 영역을 읽어 들여서 정상적인 파일시스템 형식인지를 검사</p>
    <p>3. 파티션에 대한 정보 및 마운트 대상 디렉터리에 대한 정보를 운영체제 내에 기록</p>
    <h1>파일시스템 초기화</h1>
    <p>파일목록 영역과 파일데이터 영역을 적절한 크기로 나누고</p>
    <p>파일목록 영역의 모든 파일제어블록을 빈 상태로 등록하는 작업과</p>
    <p>파일데이터 영역의 모든 블록들을 빈 블록으로 등록하는 작업을 실행</p>
    <p>윈도우는 format프로그램, 유닉스는 mkfs</p>
    <h1>파일시스템 검사</h1>
    <p>파티션별로 블록들에 오류가 있는지 여부와</p>
    <p>슈퍼블록 및 파일목록 영역에 저장된 내용에 일관성이 유지되고 있는지를 검사하고 문제가 있으면 적절히 복구</p>
    <p>유닉스는 fsck, 윈도우는 디스크 검사 프로그램 사용</p>
    <h1>디스크 블록 오류</h1>
    <p>디스크 블록의 오류는 디스크 제어기에 의해 읽기나 쓰기 작업이 이루어지지 않거나</p>
    <p>쓰기 데이터와 이것을 다시 읽었을 때의 데이터가 일치하지 않을 경우</p>
    <p>배드 블록으로 판정하고 배드 블록 목록에 추가</p>
    <p>이 블록을 사용하던 파일에서는 이 블록을 목록에서 제거</p>
    <h1>물리적 디스크 구조</h1>
    <p>디스크는 원판의 양면에 자성 물질을 고르게 입힌 형태로 제작</p>
    <p>하나의 디스크 표면에는 트랙 단위로 데이터 기록</p>
    <p>하나의 트랙은 일정한 크기의 섹터들로 구분</p>
    <p>트랙들을 합친게 실린더</p>
    <h1>디스크 용량</h1>
    <p>하나의 디스크는 여러 개의 실린더, 하나의 실린더는 여러 개의 트랙, 하나의 트랙은 여러 개의 섹터로 구성</p>
    <p>디스크 용량 = 전체 실린더 수 * 실린더 당 트랙 수 * 트랙 당 섹터 수 * 섹터 당 바이트 수</p>
    <h1>디스크 존</h1>
    <p>트랙 당 섹터의 수는 가장 짧은 안쪽의 트랙에 의해 한계가 정해짐</p>
    <p>디스크의 용량을 증가시키기 위해서는 트랙들을 몇 개의 존으로 나누고</p>
    <p>안쪽 존에 비해 바깥쪽 존에는 트랙 당 섹터 수를 크게 함</p>
    <h1>블록</h1>
    <p>운영체제에서는 일정한 개수의 섹터들을 묶어서 하나의 논리적인 단위인 블록으로 사용</p>
    <h1>블록 번호</h1>
    <p>디스크 영역을 관리할 때 논리적 블록 번호만을 사용</p>
    <p>디스크 용량</p>
    <p>- 전체 블록 수 * 블록 당 섹터 수 * 섹터 당 바이트 수</p>
    <h1>파일 오프셋으로부터 블록번호 결정</h1>
    <p>파일의 현재 오프셋을 이용하여 이에 대응되는 파일 내의 블록번호를 계산하고</p>
    <p>파일제어블록의 데이터블록 할당 정보로부터 디스크의 블록번호를 결정</p>
    <h1>디스크 명령 전달</h1>
    <p>동작의 종류(read/write), 시작 위치를 지정하는 <cylinder, track, sector>번호, 입출력 분량을 나타내는 섹터 수 및 메모리상의 주소를 제어기의 명령 레지스터에 기록</p>
  <p>디스크 제어기의 상태를 확인</p>
  <p>- 쳬ㅕ</p>
  </body>
</html>
