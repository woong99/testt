<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
    <link rel="stylesheet" href="./index.css" />
  </head>
  <body>
    <h1>파티션</h1>
    <p>디스크는 다시 몇 개의 파티션으로 구별하여 사용</p>
    <p>각각 독립적인 가상 디스크처럼 사용</p>
    <p>여러 개의 디스크들을 합쳐서 하나의 큰 파티션으로 처리 가능</p>
    <p>파일 목록 영역</p>
    <p>- 파일들의 목록을 기록</p>
    <p>- 각 파일에 대해 속성들을 기록</p>
    <p>파일 데이터 영역</p>
    <p>- 파일들의 데이터를 기록</p>
    <p>- 사용자가 기록하고자 하는 각 파일별 데이터를 기록</i>
    <h1>파일</h1>
    <p>사용자의 정보를 저장하는 독립적 단위로서 논리적으로 연속된 하나의 저장 공간</p>
    <p>예전에는 일정한 형식을 갖춘 자료인 레코드들의 연속적인 집합으로 정의</p>
    <p>유닉스 보편화 후 단순히 바이트 단위의 자료들의 연속적인 집합으로 정의</p>
    <h1>파일 시스템</h1>
    <p>
      저장 매체인 디스크 상에 체계적으로 파일들을 기록하고 관리하는 방식을 총체적으로 지칭하는 것
    </p>
    <p>
      디스크 상에 파일 목록과 파일의 데이터들을 배치하는 방식, 파일에 대한 생성/삭제/읽기/쓰기 등의
      작업을 처리하는 방식을 모두 포함
    </p>
    <p>하나의 파티션에는 한가지 형식의 파일시스템을 적용</p>
    <h1>순차접근</h1>
    <p>읽기나 쓰기 작업이 파일의 첫 바이트부터 순차적으로 이루어짐</p>
    <p>다음의 읽기/쓰기를 위한 위치가 운영체제 내부에 기록</p>
    <h1>직접접근</h1>
    <p>읽기나 쓰기 작업 요청시에 작업 위치를 동시에 지정</p>
    <h1>접근권한 검사</h1>
    <p>파일 소유자별 보호</p>
    <p>- 프로세스가 파일 접근을 위한 시스템 콜 함수를 호출했을 떄 이 프로세스의 사용자 번호와 이 파일의 소유자 번호가 일치하는지 여부를 검사</p>
    <p>파일의 소유 그룹별 보호</p>
    <p>- 이 프로세스의 사용자가 소속된 그룹 번호 중 하나와 이 파일의 소유 그룹 번호가 일치하는지 여부를 검사</p>
    <h1>접근 권한 표현 방법</h1>
    <p>파일들뿐만 아니라 입출력 장치들이나 논리적인 객체들에 대하여 접근 허용 여부에 관한 일반적인 표현 방법</p>
    <p>접근 주체인 도메인들과 접근 대상인 객체들에 대하여 접근 행렬로 표시</p>
    <h1>객체별 접근 목록</h1>
    <p>각 객체별로 도메인들에 대한 권한들을 목록으로 표시</p>
    <h1>도메인별 권한 목록</h1>
    <p>각 도메인별로 접근이 가능한 객체들에 대한 권한들의 목록을 표시</p>
    <h1>객체별 접근 목록과 도메인별 권한목록의 비교</h1>
    <p>유닉스 계열의 운영체제들은 모두 객체별 접근 목록</p>
    <p>- 세 개의 도메인만 기록하도록 제한</p>
    <p>도메인보다 객체의 개수가 월등히 많음</p>
    <p>도메인별 권한 목록의 길이가 객체별 접근 목록의 길이에 비해 아주 길고</p>
    <p>목록에서 검색이나 추가/삭제를 위해서는 훨씬 많은 시간이 소모</p>
    <h1>파일의 생성</h1>
    <p>사용되지 않고 있는 파일제어블록을 찾아서 생성될 파일의 각종 속성 정보들을 기록</p>
    <p>이름 영역과 보호모드 영역은 생성을 요청한 이름과 보호모드로 기록</p>
    <p>파일의 소유자와 소유그룹은 생성을 요청한 프로세스의 사용자와 사용자그룹의 번호로 기록</p>
    <p>이미 생성된 파일은 파일 속성을 수정하는 작업을 통하여 소유자, 소유그룹 및 보호 모드를 변경 가능</p>
    <p>파일의 크기는 0으로 기록</p>
    <h1>파일열기와 접근권한 검사</h1>
    <p>파일열기 요청을 받으면 운영체제는 파일목록 영역의 파일제어블록들을 검사하여 이름이 일치하는 것을 찾은 다음 그 속성 정보들을 활용하여 접근 권한이 있는지를 검사</p>
    <p>현재 파일열기를 요청한 정보로서 읽기나 쓰기의 여부, 프로세스의 사용자 번호 및 사용자 그룹 번호를 사용</p>
    <p>파일제어블록의 정보로서 소유자 번호, 소유그룹 번호 및 보호모드 정보를 사용하여 요청한 작업의 허용 여부를 판단</p>
    <h1>디렉터리 구조</h1>
    <p>평면 구조</p>
    <p>- 하나의 파티션에 하나의 디렉터리만 존재</p>
    <p>- 파일목록 영역에 파일제어블록들을 배열 형태로 배치</p>
    <p>트리 구조</p>
    <p>- 하나의 파티션에 여러 개의 디렉터리들이 존재</p>
    <p>- 상하관계 존재</p>
    <p>- 파일들을 특성별로 별도의 디렉터리에 저장함으로써 많은 개수 파일들을 체계적으로 관리 가능</p>
    <p>임의 구조</p>
    <p>임의의 그래프 형태로 관계 설정</p>
    <h1>트리 구조의 파일제어블록</h1>
    <p>디스크의 용량이 커지면서 대부분의 운영체제에서 트리구조의 파일시스템을 지원</p>
    <p>평면 구조</p>
    <p>- FCB에 파일이름을 포함하도록 하여 원하는 파일을 찾을 수 있음</p>
    <p>트리 구조</p>
    <p>- FCB에 파일이름을 포함하지 않음</p>
    <p>- 디렉터리의 데이터 블록에 하부 파일이나 디렉터리들의 이름을 등록</p>
    <p>- <이름, 고유번호> 형태의 쌍으로 기록 </p>
    <p>- 고유번호는 FCB들의 배열에서 몇 번째 것인지의 인덱스 번호를 활용</p>
    <h1>하드링크/심볼릭링크</h1>
    <p>하드링크나 심볼릭링크를 이용하여 제한적으로 비순환 그래프나 임의의 그래프 형태와 유사하게 사용 가능</p>
    <p>링크 기능은 임의의 디렉터리나 파일을 다른 디렉터리에 중복하여 등록 가능하게 해줌</p>
    <p>하드 링크</p>
    <p>- 동일한 파일제어블록에 비해 여러 개의 파일경로를 가질 수 있음</p>
    <p>- 동일한 파일시스템 내에서만 복수의 파일 경로들을 가질 수 있음</p>
    <p>심볼릭 링크</p>
    <p>- 별도의 파일제어블록을 할당</p>
    <p>- 단지 대상의 이름만 다른 것으로 바꿔서 사용</p>
    <h1>댕글링 포인터</h1>
    <p>하드링크는 여러 이름 중에서 일부를 삭제해도 나머지의 이름으로 파일이 유지되는데, 심볼릭 링크의 경우 대상 파일을 삭제하면 실제로는 존재하지 않는 파일로의 링크를 가짐</p>
    <h1>블록의 크기</h1>
    <p>디스크 입출력의 최소 단위는 512바이트 크기의 섹터</p>
    <p>파일에 저장 공간을 할당할 때 몇 개의 연속된 섹터들을 한 묶음으로 하는 블록 단위로 처리</p>
    <h1>유닉스의 다단계 인덱스</h1>
    <p>인덱스 블록 할당 방식을 변형하여 사용</p>
    <p>파일들의 변경이 빈번하고 임의 위치 접근 작업도 빈번하게 발생</p>
    <h1>파일 크기 한계</h1>
    <p>파일제어블록의 인덱스 테이블에 15개의 블록 기록</p>
    <p>12개까지는 해당 데이터 블록의 번호를 기록</p>
    <p>13번째 항목(1차 간접 항목)에는 인덱스 테이블을 기록한 블록의 번호를 기록</p>
    <p>- 이 블록으로 실제 데이터 블록들의 인덱스를 찾음</p>
    <p>- 한 블록 크기가 1024바이트, 블록 번호가 4바이트이면 256개의 인덱스 기록 가능</p>
    <p>14번째 항목(2차 간접 블록)</p>
    <p>- 256 ^ 2 개의 인덱스 기록</p>
    <p>15번째 항목(3차 간접 블록)</p>
    <p>- 256 ^ 3 개의 인덱스 기록</p>
    <h1>처리 속도</h1>
    <p>다단으로 갈수록 데이터 블록 번호를 확인하는데 더 많은 시간이 소요</p>
    <p>12블록 이내의 것들은 12번째 블록까지만 사용하면 되기 때문에 속도 저하 없음</p>
    <h1>윈도즈 FAT16/32</h1>
    <p>FAT는 파티션의 시작 부분에 일정한 크기로 존재</p>
    <p>블록 간의 연결에 대한 정보는 데이터블록이 아니라 FAT에 모아서 관리</p>
    <p>파티션 내의 모든 데이터 블록들의 번호를 기록할 수 있는 배열 형태</p>
    <p>FAT16은 블록번호를 16비트로 처리</p>
    <p>FAT32는 큰 디스크 용량을 처리하기 위해서 블록 번호를 32비트로 처리</p>
    <p>FAT의 내용 전체를 항상 메인 메모리에 유지하는 것이 필요</p>
    <h1>빈 블록 목록 관리</h1>
    <p>연결된 블록 할당</p>
    <p>- 파일의 데이터 블록들을 위한 연결된 블록 할당 방식을 빈 블록들을 위해 그대로 적용</p>
    <p>비트맵 할당</p>
    <p>- 파티션의 앞부분에 비트맵 영역을 따로 두고, 사용 여부를 1비트씩의 정보로 기록</p>
    <p>- 원하는 크기의 연속된 빈 블록들의 영역을 효율적으로 사용</p>
    <h1>파티션 구성</h1>
    <p>하나의 파티션은 파일목록 블록 영역과 데이터 블록 영역 외에 부트 블록과 슈퍼 블록이 사용</p>
    <p>파티션의 첫 블록을 부트 블록</p>
    <p>다음 한 블록을 슈퍼 블록</p>
    <p>다음 일정한 크기의 파일목록 영역</p>
    <p>나머지가 파일데이터 영역</p>
    <h1>부트 블록</h1>
    <p>부팅 과정에서만 사용되는 부분</p>
    <p>부팅을 위한 프로그램이 들어 있음</p>
    <p>부트 디스크일 경우에만 실제로 사용</p>
    <h1>슈퍼 블록</h1>
    <p>파일시스템에 관련된 주요 정보들을 기록하는 영역으로 사용</p>
    <p>파일시스템의 종류를 구분할 수 있는 고유 숫자</p>
    <p>파티션 이름,크기</p>
    <p>파일 개수, 파일 목록 영역의 빈 파일제어블록들의 개수</p>
    <p>빈 파일제어블록들의 목록</p>
    <p>파일데이터 영역의 빈 데이터 블록들의 개수</p>
    <p>빈 데이터 블록들의 목록 및 물리적으로 손상이 있는 블록들의 목록</p>
    <h1>파일시스템 마운트</h1>
    <p>특정 파티션을 그 속의 파일들에 대하여 사용자가 접근할 수 있도록 등록하는 절차</p>
    <p>유닉스에서는 특정 파티션을 이미 마운트된 파티션들의 임의의 디렉터리에 연결</p>
    <p>윈도우에서는 무조건 '내컴퓨터' 폴더에 지정된 이르으로 자동으로 마운트</p>
    <p>마운트를 위한 절차</p>
    <p>1. 지정된 파티션에 대해 실제 존재하는 지를 검사</p>
    <p>2. 슈퍼 블록 및 파일목록 영역을 읽어 들여서 정상적인 파일시스템 형식인지를 검사</p>
    <p>3. 파티션에 대한 정보 및 마운트 대상 디렉터리에 대한 정보를 운영체제 내에 기록</p>
    <h1>파일시스템 초기화</h1>
    <p>파일목록 영역과 파일데이터 영역을 적절한 크기로 나누고</p>
    <p>파일목록 영역의 모든 파일제어블록을 빈 상태로 등록하는 작업과</p>
    <p>파일데이터 영역의 모든 블록들을 빈 블록으로 등록하는 작업을 실행</p>
    <p>윈도우는 format프로그램, 유닉스는 mkfs</p>
    <h1>파일시스템 검사</h1>
    <p>파티션별로 블록들에 오류가 있는지 여부와</p>
    <p>슈퍼블록 및 파일목록 영역에 저장된 내용에 일관성이 유지되고 있는지를 검사하고 문제가 있으면 적절히 복구</p>
    <p>유닉스는 fsck, 윈도우는 디스크 검사 프로그램 사용</p>
    <h1>디스크 블록 오류</h1>
    <p>디스크 블록의 오류는 디스크 제어기에 의해 읽기나 쓰기 작업이 이루어지지 않거나</p>
    <p>쓰기 데이터와 이것을 다시 읽었을 때의 데이터가 일치하지 않을 경우</p>
    <p>배드 블록으로 판정하고 배드 블록 목록에 추가</p>
    <p>이 블록을 사용하던 파일에서는 이 블록을 목록에서 제거</p>
    <h1>물리적 디스크 구조</h1>
    <p>디스크는 원판의 양면에 자성 물질을 고르게 입힌 형태로 제작</p>
    <p>하나의 디스크 표면에는 트랙 단위로 데이터 기록</p>
    <p>하나의 트랙은 일정한 크기의 섹터들로 구분</p>
    <p>트랙들을 합친게 실린더</p>
    <h1>디스크 용량</h1>
    <p>하나의 디스크는 여러 개의 실린더, 하나의 실린더는 여러 개의 트랙, 하나의 트랙은 여러 개의 섹터로 구성</p>
    <p>디스크 용량 = 전체 실린더 수 * 실린더 당 트랙 수 * 트랙 당 섹터 수 * 섹터 당 바이트 수</p>
    <h1>디스크 존</h1>
    <p>트랙 당 섹터의 수는 가장 짧은 안쪽의 트랙에 의해 한계가 정해짐</p>
    <p>디스크의 용량을 증가시키기 위해서는 트랙들을 몇 개의 존으로 나누고</p>
    <p>안쪽 존에 비해 바깥쪽 존에는 트랙 당 섹터 수를 크게 함</p>
    <h1>블록</h1>
    <p>운영체제에서는 일정한 개수의 섹터들을 묶어서 하나의 논리적인 단위인 블록으로 사용</p>
    <h1>블록 번호</h1>
    <p>디스크 영역을 관리할 때 논리적 블록 번호만을 사용</p>
    <p>디스크 용량</p>
    <p>- 전체 블록 수 * 블록 당 섹터 수 * 섹터 당 바이트 수</p>
    <h1>파일 오프셋으로부터 블록번호 결정</h1>
    <p>파일의 현재 오프셋을 이용하여 이에 대응되는 파일 내의 블록번호를 계산하고</p>
    <p>파일제어블록의 데이터블록 할당 정보로부터 디스크의 블록번호를 결정</p>
    <h1>디스크 명령 전달</h1>
    <p>동작의 종류(read/write), 시작 위치를 지정하는 <cylinder, track, sector>번호, 입출력 분량을 나타내는 섹터 수 및 메모리상의 주소를 제어기의 명령 레지스터에 기록</p>
    <p>디스크 제어기의 상태를 확인</p>
    <p>- CPU는 디스크 제어기의 상태 레지스터를 읽음</p>
    <h1>시스템 콜 처리</h1>
    <p>프로세스가 디스크 입출력 작업을 요청하면 OS는 대상이 되는 디스크와 논리적 블록 번호를 결정한 다음</p>
    <p>해당 디스크 큐에 이 프로세스를 대기 상태로 등록</p>
    <p>요청한 블록 번호 및 메모리 주소도 힘께 기록</p>
    <p>디스크 제어기가 쉬고 있는 상태이면</p>
    <p>- 디스크 큐에서 하나를 선택하고 요청한 블록 번호 block에 대응되는</p>
    <p>- <cylinder, track, sector>를 계산하여 디스크 제어기에 작업 명령을 전달</p>
    <p>다음 스케줄링을 통하여 레디 큐의 다른 프로세스를 선택하고 문맥 교환을 실시</p>
    <h1>디스크 제어기의 작업 실행</h1>
    <p>작업 명령을 접수하면</p>
    <p>- 읽기이면 지정된 섹터로부터 지정된 섹터 수만큼 읽어 내어 지정된 메모리 주소에 기록</p>
    <p>- 쓰기이면 메모리의 내용을 읽어서 지정된 섹터들에 기록</p>
    <h1>디스크 인터럽트 처리</h1>
    <p>디스크 제어기로부터 작업완료를 나타내는 인터럽트가 발생하면</p>
    <p>CPU는 그 처리 루틴에서 이 작업을 요청한 프로세스를 디스크 큐에서 제거하고</p>
    <p>실행가능 상태로 전환하여 레디 큐에 등록</p>
    <p>만약 이때 디스크 큐가 비어있지 않으면 다음 프로세스의 요구 정보에 따라 디스크 제어기에 적절한 작업 명령을 전달</p>
    <h1>디스크 스케줄링</h1>
    <p>디스크 헤드가 요청된 실린더 위치까지 이동하는 시간을 줄이기 위해서 요청된 블록들의 실린더 번호를 활용하여 처리 순서를 조정함으로써 헤드가 이동하는 전체 시간을 단축함</p>
    <h1>디스크 입출력 소요 시간</h1>
    <p>헤드가 원하는 섹터까지 이동하는 데 필요한 접근 시간 + </p>
    <p>- 액추에이터의 회전에 의해 헤드가 원하는 트랙까지 이동하는데 필요한 탐색 시간 + 스핀들의 회전에 의해 원하는 섹터가 헤드 아래를 통과하기 시작할 때까지의 회전지연시간</p>
    <p>원하는 데이터를 전송하는데 소요되는 전송시간</p>
    <h1>소요시간 단축방안</h1>
    <p>탐색 시간</p>
    <p>- 디스크 스케줄링으로 작업 순서를 조정함으로써 전체 작업을 완료할때까지의 헤드의 이동거리를 줄일 수 있음</p>
    <p>회전지연 시간</p>
    <p>- 동일한 실린더에 위치한 블록들에 대해서는 디스크가 회전하는 순서대로 작업을 처리하면 회전지연 시간을 줄일 수 있음</p>
    <p>전송 시간</p>
    <p>- 디스크마다 고정된 전송 속도를 가지고 있으므로 불가능</p>
    <h1>FCFS(First-Come First-Served)</h1>
    <p>입출력 작업이 요청된 시간을 기준</p>
    <h1>SSTF(Shortest Seek Time First)</h1>
    <p>디스크 큐에 있는 블록들 중에서 현재의 헤드 위치를 기준으로 하여 가장 가까운 위치의 블록을 먼저 처리</p>
    <p>기아 문제 발생</p>
    <h1>SCAN</h1>
    <p>헤드가 한 쪽 방향으로 이동하면서 중간에 위치한 블록들을 처리해주고, 다시 반대 방향으로 이동하면서 동일한 방법으로 처리하는 것을 반복</p>
    <p>SSTF보다 탐색시간이 더 소요되지만 기아 문제는 해결</p>
    <h1>LOOK</h1>
    <p>SCAN 방식을 개선한 것</p>
    <p>어느 한 방향으로 헤드가 이동하는 과정에서 그 방향으로는 더 이상 대기중인 작업이 없다면 끝단의 실런더까지 이동하지 말고 바로 반대 방향으로 이동 방향을 전환하는 방식</p>
    <h1>C-SCAN, C-LOOK</h1>
    <p>SCAN과 LOOK에서는 양 끝단의 실린더에 비해 중간 부분의 실린더에 위치한 블록들이 상대적으로 자주 처리</p>
    <p>어느 한쪽 방향으로 이동하면서만 작업을 처리하고 반대 방향으로 이동할 때에는 그냥 통과하는 방식</p>
    <h1>우선순위</h1>
    <p>우선순위를 부여하여 우선순위가 높은 작업을 먼저 처리</p>
    <h1>N단계 SCAN</h1>
    <p>위 방식들은 새로운 요청이 아직 지나가지 않은 위치에 많이 들어오게 되면 이들은 금방 처리되는 대신 지나간 위치의 요청은 지나치게 오랫동안 기다려야함</p>
    <p>SCAN + FCFS</p>
    <p>요청된 작업들을 순서대로 N개씩 그룹으로 묶고 각 그룹별로 SCAN을 적용</p>
    <p>그룹간에는 FCFS를 적용</p>
    <h1>마감시간스케줄러</h1>
    <p>리눅스에서 사용</p>
    <p>C-LOOK을 적용하면서도 지나치게 오래 기다리는 작업이 없도록 개선한 것</p>
    <p>모든 작업요청들은 C-LOOK 방식으로 큐에 삽입하면서 동시에 FCFS 큐에도 등록</p>
    <p>처리가 완료된 작업은 각 큐에서 모두 제거</p>
    <p>기본적으로 C-LOOK으로 작업들을 처리하면서, FCFS 큐에서 대기한 시간이 일정 기준을 초과하는 작업들이 발생하면 이들을 먼저 처리</p>
    <p>대기시간기준은 읽기 작업과 쓰기 작업이 다를 수 있으므로 두 종류를 별도의 FCFS큐에</p>
    <h1>디스크 스케줄링을 위해서 파일 읽기/쓰기 요청에 대해 디스크 큐에 등록하고 제거하는 과정 설명</h1>
    <p>요청된 블록은 C-LOOK 정책에 맞게 디스크 큐에 등록. 디스크 제어기가 쉬고 있으면 바로 제 어기에 명령을 전달함. 디스크 제어기로부터 완료 인터럽트 신호가 오면 완료된 요청을 큐에서 제거하고, 남은 요청들이 있으면 정책에 따라 다음 요청을 선택해 제어기에 명령을 전달함.</p>
    <h1>스케줄링 결과 비교</h1>
    <p>속도는 SSTF가 가장 유리, 기아문제 발생</p>
    <p>SCAN방식</p>
    <p>- SSTF보다는 시간이 더 소요되지만 기아 문제는 해결</p>
    <p>- 양 끝단의 실린더들은 상대적으로 실행 기회가 적음</p>
    <p>C-SCAN방식</p>
    <p>기회의 불균형을 해소하지만 SCAN에 비해서는 더 많은 시간 소비</p>
    <h1>디스크 입출력의 성능개선 방안</h1>
    <p>디스크 캐시</p>
    <p>- 디스크 읽기나 쓰기 작업 후에 그 내용을 커널 내부의 디스크 캐시 메모리에 보관</p>
    <p>- 이후 동일한 블록에 대한 읽기 작업이 요청되면 이 캐시의 내용을 그대로 사용함</p>
    <p>- 디스크 읽기 작업 횟수를 줄임</p>
    <p>지연 기록 방식</p>
    <p>- 쓰기 작업 요청 시 실제로 디스크 제어기에 쓰기 작업 명령을 보내지 말고</p>
    <p>- 커널 내부의 버퍼 메모리에만 보관</p>
    <p>- 이후 동일한 블록에 대한 쓰기 작업 요청 시 이전의 쓰기 데이터는 무의미하므로 새로운 데이터로 대치</p>
    <p>- 최종 내용에 대해서만 디스크 제어기에 쓰기 작업을 요쳥</p>
    <h1>지연기록 방식의 문제점</h1>
    <p>컴퓨터가 갑자기 꺼지면 파일 시스템의 데이터 일관성에 문제가 발생 </p>
    <p>유닉스와 같이 안정적인 시스템에서 입출력 성능을 중요시하는 운영체제에서 적용</p>
    <p>클러스터</p>
    <p>- 연속된 블록들의 그룹</p>
    <p>- 파일에 블록들을 할당할 떄 클러스터 단위로 할당</p>
    <p>-- 연결된 블록 할당 방식이나 인덱스 블록 할당 방식을 사용가능</p>
    <p>-- 가능한 한 인접한 블록들을 할당할 수 있도록 개선</p>
    <p>- 내부 단편화 문제</p>
    <p>-- 각 파일의 마지막 클러스터를 여러 파일들이 공유하여 블록 단위로 나누어 사용하도록 함으로써 해결</p>
    <p>조각모음</p>
    <p>- 파일들 간 또는 파일들과 빈 데이터 블록 목록 간에 블록들을 서로 교환</p>
    <p>- 쓰레기 수집</p>
    <p>-- 빈 블록들도 연속된 영역이 되어서 새로운 파일에 할당할 때 연속된 데이터 블록들이 차례대로 할당되도록 함 </p>
    <h1>플레시 메모리와 SSD</h1>
    <p>가볍고 속도 빠르고 전력 소모량 적고 외부의 충격에도 강함</p>
    <p>좀 비쌈</p>
    <p>플래시 메모리의 단점</p>
    <p>- 제자리에 덮어쓰기가 되지 않음</p>
    <p>- 이미 데이터가 기록되어 있는 부분에는 지우기 절차를 거쳐야만 쓰기가 가능</p>
    <p>해결방법</p>
    <p>- 플래시 메모리의 특성을 고려한 새로운 파일시스템 사용: 리누스의 JFFS, F2FS</p>
    <p>- 기존 파일 시스템을 그대로 사용하도록 저장장치만 SSD사용</p>
    <p>-- 대신 SSD내부에 플래시 변환 계층(FTL)을 두어 파일 시스템에서 요청한 논리적 위치 정보를 SSD 내부에서 실제로 저장한 위치 정보로 매핑하여 처리</p>
    <h1>SSD의 구성</h1>
    <p>하나의 SSD는 여러 개의 플래시 메모리 칩들로 구성</p>
    <p>하나의 칩은 블록들의 집합으로 구성</p>
    <p>각 블록은 페이지들의 집합으로 구성</p>
    <p>읽기와 쓰기는 페이지 단위로 처리</p>
    <p>지우기는 한 블록 단위로만 처리</p>
    <h1>플래시 변환 계층</h1>
    <p>FTL을 적용한 SSD는 파일 시스템에서는 페이지들의 집합으로 간주하고 페이지 단위로 읽기와 쓰기를 요청</p>
    <p>여기에 사용되는 논리적 페이지 번호를 SSD 내부에서 FTL에서는 실제로 기록된 물리적 페이지 번호로 변환하여 사용</p>
    <p>SSD 내부에는 전용 제어기가 있어서 FTL의 기능을 실행</p>
    <p>파일 시스템으로부터 논리적 페이지 번호 (LPN)로 지정된 특정 페이지의 쓰기 요청이 오면 FTL에서는 빈 페이지를 선택하여 기록하고 그 물리적 페이지 번호 (PPN)를 LPN과의 쌍으로 내부에 매핑 정보에 등록</p>
    <p>이 LPN 페이지에 대한 읽기 요청이 오면 매핑 정보로부터 대응되는 PPN을 찾아서 그 페이지의 내용을 읽음</p>
    <p>동일한 LPN에 새로운 쓰기 요청이 오면 다른 빈 페이지를 선택하여 기록하고 그 PPN으로 매핑 정보를 갱신</p>
    <h1>가비지 컬렉션과 웨어 레벨링</h1>
    <p>FTL의 기능에는 가비지 컬렉션과 웨어 레벨링 기능이 포함</p>
    <p>블록들에는 무효 페이지들과 유효 페이지들이 혼합</p>
    <p>일부 페이지만 유효한 블록들에 대해서는 새로운 블록에 유효한 페이지들만 복사한 후에 이전 블록들은 지워서 재활용하는 가비지 컬렉션 작업을 수행</p>
    <p>가능하면 전체 블록들에 골고루 쓰고 지우기가 이루어지도록 빈 페이지들을 적절히 배치하는 것이 중요</p>
    <h1>Trim 기능</h1>
    <p>SSD 자체로는 어떤 페이지가 계속 데이터를 보존해야 할지를 구별할 수가 없음</p>
    <p>SSD는 트림 요청을 받은 논리적 페이지들에 대해서는 바로 무효로 등록하고 가비지 컬렉션 작업에서 이 페이지들의 내용은 더 이상 보관하지 않는다.</p>
  </body>
</html>
