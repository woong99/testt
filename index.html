<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
    <link rel="stylesheet" href="./index.css" />
  </head>
  <body>
    <h1>파티션</h1>
    <p>디스크는 다시 몇 개의 파티션으로 구별하여 사용</p>
    <p>각각 독립적인 가상 디스크처럼 사용</p>
    <p>여러 개의 디스크들을 합쳐서 하나의 큰 파티션으로 처리 가능</p>
    <p>파일 목록 영역</p>
    <p>- 파일들의 목록을 기록</p>
    <p>- 각 파일에 대해 속성들을 기록</p>
    <p>파일 데이터 영역</p>
    <p>- 파일들의 데이터를 기록</p>
    <p>- 사용자가 기록하고자 하는 각 파일별 데이터를 기록</i>
    <h1>파일</h1>
    <p>사용자의 정보를 저장하는 독립적 단위로서 논리적으로 연속된 하나의 저장 공간</p>
    <p>예전에는 일정한 형식을 갖춘 자료인 레코드들의 연속적인 집합으로 정의</p>
    <p>유닉스 보편화 후 단순히 바이트 단위의 자료들의 연속적인 집합으로 정의</p>
    <h1>파일 시스템</h1>
    <p>
      저장 매체인 디스크 상에 체계적으로 파일들을 기록하고 관리하는 방식을 총체적으로 지칭하는 것
    </p>
    <p>
      디스크 상에 파일 목록과 파일의 데이터들을 배치하는 방식, 파일에 대한 생성/삭제/읽기/쓰기 등의
      작업을 처리하는 방식을 모두 포함
    </p>
    <p>하나의 파티션에는 한가지 형식의 파일시스템을 적용</p>
    <h1>순차접근</h1>
    <p>읽기나 쓰기 작업이 파일의 첫 바이트부터 순차적으로 이루어짐</p>
    <p>다음의 읽기/쓰기를 위한 위치가 운영체제 내부에 기록</p>
    <h1>직접접근</h1>
    <p>읽기나 쓰기 작업 요청시에 작업 위치를 동시에 지정</p>
    <h1>접근권한 검사</h1>
    <p>파일 소유자별 보호</p>
    <p>- 프로세스가 파일 접근을 위한 시스템 콜 함수를 호출했을 떄 이 프로세스의 사용자 번호와 이 파일의 소유자 번호가 일치하는지 여부를 검사</p>
    <p>파일의 소유 그룹별 보호</p>
    <p>- 이 프로세스의 사용자가 소속된 그룹 번호 중 하나와 이 파일의 소유 그룹 번호가 일치하는지 여부를 검사</p>
    <h1>접근 권한 표현 방법</h1>
    <p>파일들뿐만 아니라 입출력 장치들이나 논리적인 객체들에 대하여 접근 허용 여부에 관한 일반적인 표현 방법</p>
    <p>접근 주체인 도메인들과 접근 대상인 객체들에 대하여 접근 행렬로 표시</p>
    <h1>객체별 접근 목록</h1>
    <p>각 객체별로 도메인들에 대한 권한들을 목록으로 표시</p>
    <h1>도메인별 권한 목록</h1>
    <p>각 도메인별로 접근이 가능한 객체들에 대한 권한들의 목록을 표시</p>
    <h1>객체별 접근 목록과 도메인별 권한목록의 비교</h1>
    <p>유닉스 계열의 운영체제들은 모두 객체별 접근 목록</p>
    <p>- 세 개의 도메인만 기록하도록 제한</p>
    <p>도메인보다 객체의 개수가 월등히 많음</p>
    <p>도메인별 권한 목록의 길이가 객체별 접근 목록의 길이에 비해 아주 길고</p>
    <p>목록에서 검색이나 추가/삭제를 위해서는 훨씬 많은 시간이 소모</p>
    <h1>파일의 생성</h1>
    <p>사용되지 않고 있는 파일제어블록을 찾아서 생성될 파일의 각종 속성 정보들을 기록</p>
    <p>이름 영역과 보호모드 영역은 생성을 요청한 이름과 보호모드로 기록</p>
    <p>파일의 소유자와 소유그룹은 생성을 요청한 프로세스의 사용자와 사용자그룹의 번호로 기록</p>
    <p>이미 생성된 파일은 파일 속성을 수정하는 작업을 통하여 소유자, 소유그룹 및 보호 모드를 변경 가능</p>
    <p>파일의 크기는 0으로 기록</p>
    <h1>파일열기와 접근권한 검사</h1>
    <p>파일열기 요청을 받으면 운영체제는 파일목록 영역의 파일제어블록들을 검사하여 이름이 일치하는 것을 찾은 다음 그 속성 정보들을 활용하여 접근 권한이 있는지를 검사</p>
    <p>현재 파일열기를 요청한 정보로서 읽기나 쓰기의 여부, 프로세스의 사용자 번호 및 사용자 그룹 번호를 사용</p>
    <p>파일제어블록의 정보로서 소유자 번호, 소유그룹 번호 및 보호모드 정보를 사용하여 요청한 작업의 허용 여부를 판단</p>
    <h1>디렉터리 구조</h1>
    <p>평면 구조</p>
    <p>- 하나의 파티션에 하나의 디렉터리만 존재</p>
    <p>- 파일목록 영역에 파일제어블록들을 배열 형태로 배치</p>
    <p>트리 구조</p>
    <p>- 하나의 파티션에 여러 개의 디렉터리들이 존재</p>
    <p>- 상하관계 존재</p>
    <p>- 파일들을 특성별로 별도의 디렉터리에 저장함으로써 많은 개수 파일들을 체계적으로 관리 가능</p>
    <p>임의 구조</p>
    <p>임의의 그래프 형태로 관계 설정</p>
    <h1>트리 구조의 파일제어블록</h1>
    <p>디스크의 용량이 커지면서 대부분의 운영체제에서 트리구조의 파일시스템을 지원</p>
    <p>평면 구조</p>
    <p>- FCB에 파일이름을 포함하도록 하여 원하는 파일을 찾을 수 있음</p>
    <p>트리 구조</p>
    <p>- FCB에 파일이름을 포함하지 않음</p>
    <p>- 디렉터리의 데이터 블록에 하부 파일이나 디렉터리들의 이름을 등록</p>
    <p>- <이름, 고유번호> 형태의 쌍으로 기록 </p>
    <p>- 고유번호는 FCB들의 배열에서 몇 번째 것인지의 인덱스 번호를 활용</p>
    <h1>하드링크/심볼릭링크</h1>
    <p>하드링크나 심볼릭링크를 이용하여 제한적으로 비순환 그래프나 임의의 그래프 형태와 유사하게 사용 가능</p>
    <p>링크 기능은 임의의 디렉터리나 파일을 다른 디렉터리에 중복하여 등록 가능하게 해줌</p>
    <p>하드 링크</p>
    <p>- 동일한 파일제어블록에 비해 여러 개의 파일경로를 가질 수 있음</p>
    <p>- 동일한 파일시스템 내에서만 복수의 파일 경로들을 가질 수 있음</p>
    <p>심볼릭 링크</p>
    <p>- 별도의 파일제어블록을 할당</p>
    <p>- 단지 대상의 이름만 다른 것으로 바꿔서 사용</p>
    <h1>댕글링 포인터</h1>
    <p>하드링크는 여러 이름 중에서 일부를 삭제해도 나머지의 이름으로 파일이 유지되는데, 심볼릭 링크의 경우 대상 파일을 삭제하면 실제로는 존재하지 않는 파일로의 링크를 가짐</p>
    <h1>블록의 크기</h1>
    <p>디스크 입출력의 최소 단위는 512바이트 크기의 섹터</p>
    <p>파일에 저장 공간을 할당할 때 몇 개의 연속된 섹터들을 한 묶음으로 하는 블록 단위로 처리</p>
    <h1>유닉스의 다단계 인덱스</h1>
    <p>인덱스 블록 할당 방식을 변형하여 사용</p>
    <p>파일들의 변경이 빈번하고 임의 위치 접근 작업도 빈번하게 발생</p>
    <h1>파일 크기 한계</h1>
    <p>파일제어블록의 인덱스 테이블에 15개의 블록 기록</p>
    <p>12개까지는 해당 데이터 블록의 번호를 기록</p>
    <p>13번째 항목(1차 간접 항목)에는 인덱스 테이블을 기록한 블록의 번호를 기록</p>
    <p>- 이 블록으로 실제 데이터 블록들의 인덱스를 찾음</p>
    <p>- 한 블록 크기가 1024바이트, 블록 번호가 4바이트이면 256개의 인덱스 기록 가능</p>
    <p>14번째 항목(2차 간접 블록)</p>
    <p>- 256 ^ 2 개의 인덱스 기록</p>
    <p>15번째 항목(3차 간접 블록)</p>
    <p>- 256 ^ 3 개의 인덱스 기록</p>
    <h1>처리 속도</h1>
    <p>다단으로 갈수록 데이터 블록 번호를 확인하는데 더 많은 시간이 소요</p>
    <p>12블록 이내의 것들은 12번째 블록까지만 사용하면 되기 때문에 속도 저하 없음</p>
    <h1>윈도즈 FAT16/32</h1>
    <p>FAT는 파티션의 시작 부분에 일정한 크기로 존재</p>
    <p>블록 간의 연결에 대한 정보는 데이터블록이 아니라 FAT에 모아서 관리</p>
    <p>파티션 내의 모든 데이터 블록들의 번호를 기록할 수 있는 배열 형태</p>
    <p>FAT16은 블록번호를 16비트로 처리</p>
    <p>FAT32는 큰 디스크 용량을 처리하기 위해서 블록 번호를 32비트로 처리</p>
    <p>FAT의 내용 전체를 항상 메인 메모리에 유지하는 것이 필요</p>
    <h1>빈 블록 목록 관리</h1>
    <p>연결된 블록 할당</p>
    <p>- 파일의 데이터 블록들을 위한 연결된 블록 할당 방식을 빈 블록들을 위해 그대로 적용</p>
    <p>비트맵 할당</p>
    <p>- 파티션의 앞부분에 비트맵 영역을 따로 두고, 사용 여부를 1비트씩의 정보로 기록</p>
    <p>- 원하는 크기의 연속된 빈 블록들의 영역을 효율적으로 사용</p>
    <h1>파티션 구성</h1>
    <p>하나의 파티션은 파일목록 블록 영역과 데이터 블록 영역 외에 부트 블록과 슈퍼 블록이 사용</p>
    <p>파티션의 첫 블록을 부트 블록</p>
    <p>다음 한 블록을 슈퍼 블록</p>
    <p>다음 일정한 크기의 파일목록 영역</p>
    <p>나머지가 파일데이터 영역</p>
    <h1>부트 블록</h1>
    <p>부팅 과정에서만 사용되는 부분</p>
    <p>부팅을 위한 프로그램이 들어 있음</p>
    <p>부트 디스크일 경우에만 실제로 사용</p>
    <h1>슈퍼 블록</h1>
    <p>파일시스템에 관련된 주요 정보들을 기록하는 영역으로 사용</p>
    <p>파일시스템의 종류를 구분할 수 있는 고유 숫자</p>
    <p>파티션 이름,크기</p>
    <p>파일 개수, 파일 목록 영역의 빈 파일제어블록들의 개수</p>
    <p>빈 파일제어블록들의 목록</p>
    <p>파일데이터 영역의 빈 데이터 블록들의 개수</p>
    <p>빈 데이터 블록들의 목록 및 물리적으로 손상이 있는 블록들의 목록</p>
    <h1>파일시스템 마운트</h1>
    <p>특정 파티션을 그 속의 파일들에 대하여 사용자가 접근할 수 있도록 등록하는 절차</p>
    <p>유닉스에서는 특정 파티션을 이미 마운트된 파티션들의 임의의 디렉터리에 연결</p>
    <p>윈도우에서는 무조건 '내컴퓨터' 폴더에 지정된 이르으로 자동으로 마운트</p>
    <p>마운트를 위한 절차</p>
    <p>1. 지정된 파티션에 대해 실제 존재하는 지를 검사</p>
    <p>2. 슈퍼 블록 및 파일목록 영역을 읽어 들여서 정상적인 파일시스템 형식인지를 검사</p>
    <p>3. 파티션에 대한 정보 및 마운트 대상 디렉터리에 대한 정보를 운영체제 내에 기록</p>
    <h1>파일시스템 초기화</h1>
    <p>파일목록 영역과 파일데이터 영역을 적절한 크기로 나누고</p>
    <p>파일목록 영역의 모든 파일제어블록을 빈 상태로 등록하는 작업과</p>
    <p>파일데이터 영역의 모든 블록들을 빈 블록으로 등록하는 작업을 실행</p>
    <p>윈도우는 format프로그램, 유닉스는 mkfs</p>
    <h1>파일시스템 검사</h1>
    <p>파티션별로 블록들에 오류가 있는지 여부와</p>
    <p>슈퍼블록 및 파일목록 영역에 저장된 내용에 일관성이 유지되고 있는지를 검사하고 문제가 있으면 적절히 복구</p>
    <p>유닉스는 fsck, 윈도우는 디스크 검사 프로그램 사용</p>
    <h1>디스크 블록 오류</h1>
    <p>디스크 블록의 오류는 디스크 제어기에 의해 읽기나 쓰기 작업이 이루어지지 않거나</p>
    <p>쓰기 데이터와 이것을 다시 읽었을 때의 데이터가 일치하지 않을 경우</p>
    <p>배드 블록으로 판정하고 배드 블록 목록에 추가</p>
    <p>이 블록을 사용하던 파일에서는 이 블록을 목록에서 제거</p>
    <h1>물리적 디스크 구조</h1>
    <p>디스크는 원판의 양면에 자성 물질을 고르게 입힌 형태로 제작</p>
    <p>하나의 디스크 표면에는 트랙 단위로 데이터 기록</p>
    <p>하나의 트랙은 일정한 크기의 섹터들로 구분</p>
    <p>트랙들을 합친게 실린더</p>
    <h1>디스크 용량</h1>
    <p>하나의 디스크는 여러 개의 실린더, 하나의 실린더는 여러 개의 트랙, 하나의 트랙은 여러 개의 섹터로 구성</p>
    <p>디스크 용량 = 전체 실린더 수 * 실린더 당 트랙 수 * 트랙 당 섹터 수 * 섹터 당 바이트 수</p>
    <h1>디스크 존</h1>
    <p>트랙 당 섹터의 수는 가장 짧은 안쪽의 트랙에 의해 한계가 정해짐</p>
    <p>디스크의 용량을 증가시키기 위해서는 트랙들을 몇 개의 존으로 나누고</p>
    <p>안쪽 존에 비해 바깥쪽 존에는 트랙 당 섹터 수를 크게 함</p>
    <h1>블록</h1>
    <p>운영체제에서는 일정한 개수의 섹터들을 묶어서 하나의 논리적인 단위인 블록으로 사용</p>
    <h1>블록 번호</h1>
    <p>디스크 영역을 관리할 때 논리적 블록 번호만을 사용</p>
    <p>디스크 용량</p>
    <p>- 전체 블록 수 * 블록 당 섹터 수 * 섹터 당 바이트 수</p>
    <h1>파일 오프셋으로부터 블록번호 결정</h1>
    <p>파일의 현재 오프셋을 이용하여 이에 대응되는 파일 내의 블록번호를 계산하고</p>
    <p>파일제어블록의 데이터블록 할당 정보로부터 디스크의 블록번호를 결정</p>
    <h1>디스크 명령 전달</h1>
    <p>동작의 종류(read/write), 시작 위치를 지정하는 <cylinder, track, sector>번호, 입출력 분량을 나타내는 섹터 수 및 메모리상의 주소를 제어기의 명령 레지스터에 기록</p>
    <p>디스크 제어기의 상태를 확인</p>
    <p>- CPU는 디스크 제어기의 상태 레지스터를 읽음</p>
    <h1>시스템 콜 처리</h1>
    <p>프로세스가 디스크 입출력 작업을 요청하면 OS는 대상이 되는 디스크와 논리적 블록 번호를 결정한 다음</p>
    <p>해당 디스크 큐에 이 프로세스를 대기 상태로 등록</p>
    <p>요청한 블록 번호 및 메모리 주소도 힘께 기록</p>
    <p>디스크 제어기가 쉬고 있는 상태이면</p>
    <p>- 디스크 큐에서 하나를 선택하고 요청한 블록 번호 block에 대응되는</p>
    <p>- <cylinder, track, sector>를 계산하여 디스크 제어기에 작업 명령을 전달</p>
    <p>다음 스케줄링을 통하여 레디 큐의 다른 프로세스를 선택하고 문맥 교환을 실시</p>
    <h1>디스크 제어기의 작업 실행</h1>
    <p>작업 명령을 접수하면</p>
    <p>- 읽기이면 지정된 섹터로부터 지정된 섹터 수만큼 읽어 내어 지정된 메모리 주소에 기록</p>
    <p>- 쓰기이면 메모리의 내용을 읽어서 지정된 섹터들에 기록</p>
    <h1>디스크 인터럽트 처리</h1>
    <p>디스크 제어기로부터 작업완료를 나타내는 인터럽트가 발생하면</p>
    <p>CPU는 그 처리 루틴에서 이 작업을 요청한 프로세스를 디스크 큐에서 제거하고</p>
    <p>실행가능 상태로 전환하여 레디 큐에 등록</p>
    <p>만약 이때 디스크 큐가 비어있지 않으면 다음 프로세스의 요구 정보에 따라 디스크 제어기에 적절한 작업 명령을 전달</p>
    <h1>디스크 스케줄링</h1>
    <p>디스크 헤드가 요청된 실린더 위치까지 이동하는 시간을 줄이기 위해서 요청된 블록들의 실린더 번호를 활용하여 처리 순서를 조정함으로써 헤드가 이동하는 전체 시간을 단축함</p>
    <h1>디스크 입출력 소요 시간</h1>
    <p>헤드가 원하는 섹터까지 이동하는 데 필요한 접근 시간 + </p>
    <p>- 액추에이터의 회전에 의해 헤드가 원하는 트랙까지 이동하는데 필요한 탐색 시간 + 스핀들의 회전에 의해 원하는 섹터가 헤드 아래를 통과하기 시작할 때까지의 회전지연시간</p>
    <p>원하는 데이터를 전송하는데 소요되는 전송시간</p>
    <h1>소요시간 단축방안</h1>
    <p>탐색 시간</p>
    <p>- 디스크 스케줄링으로 작업 순서를 조정함으로써 전체 작업을 완료할때까지의 헤드의 이동거리를 줄일 수 있음</p>
    <p>회전지연 시간</p>
    <p>- 동일한 실린더에 위치한 블록들에 대해서는 디스크가 회전하는 순서대로 작업을 처리하면 회전지연 시간을 줄일 수 있음</p>
    <p>전송 시간</p>
    <p>- 디스크마다 고정된 전송 속도를 가지고 있으므로 불가능</p>
    <h1>FCFS(First-Come First-Served)</h1>
    <p>입출력 작업이 요청된 시간을 기준</p>
    <h1>SSTF(Shortest Seek Time First)</h1>
    <p>디스크 큐에 있는 블록들 중에서 현재의 헤드 위치를 기준으로 하여 가장 가까운 위치의 블록을 먼저 처리</p>
    <p>기아 문제 발생</p>
    <h1>SCAN</h1>
    <p>헤드가 한 쪽 방향으로 이동하면서 중간에 위치한 블록들을 처리해주고, 다시 반대 방향으로 이동하면서 동일한 방법으로 처리하는 것을 반복</p>
    <p>SSTF보다 탐색시간이 더 소요되지만 기아 문제는 해결</p>
    <h1>LOOK</h1>
    <p>SCAN 방식을 개선한 것</p>
    <p>어느 한 방향으로 헤드가 이동하는 과정에서 그 방향으로는 더 이상 대기중인 작업이 없다면 끝단의 실런더까지 이동하지 말고 바로 반대 방향으로 이동 방향을 전환하는 방식</p>
    <h1>C-SCAN, C-LOOK</h1>
    <p>SCAN과 LOOK에서는 양 끝단의 실린더에 비해 중간 부분의 실린더에 위치한 블록들이 상대적으로 자주 처리</p>
    <p>어느 한쪽 방향으로 이동하면서만 작업을 처리하고 반대 방향으로 이동할 때에는 그냥 통과하는 방식</p>
    <h1>우선순위</h1>
    <p>우선순위를 부여하여 우선순위가 높은 작업을 먼저 처리</p>
    <h1>N단계 SCAN</h1>
    <p>위 방식들은 새로운 요청이 아직 지나가지 않은 위치에 많이 들어오게 되면 이들은 금방 처리되는 대신 지나간 위치의 요청은 지나치게 오랫동안 기다려야함</p>
    <p>SCAN + FCFS</p>
    <p>요청된 작업들을 순서대로 N개씩 그룹으로 묶고 각 그룹별로 SCAN을 적용</p>
    <p>그룹간에는 FCFS를 적용</p>
    <h1>마감시간스케줄러</h1>
    <p>리눅스에서 사용</p>
    <p>C-LOOK을 적용하면서도 지나치게 오래 기다리는 작업이 없도록 개선한 것</p>
    <p>모든 작업요청들은 C-LOOK 방식으로 큐에 삽입하면서 동시에 FCFS 큐에도 등록</p>
    <p>처리가 완료된 작업은 각 큐에서 모두 제거</p>
    <p>기본적으로 C-LOOK으로 작업들을 처리하면서, FCFS 큐에서 대기한 시간이 일정 기준을 초과하는 작업들이 발생하면 이들을 먼저 처리</p>
    <p>대기시간기준은 읽기 작업과 쓰기 작업이 다를 수 있으므로 두 종류를 별도의 FCFS큐에</p>
    <h1>디스크 스케줄링을 위해서 파일 읽기/쓰기 요청에 대해 디스크 큐에 등록하고 제거하는 과정 설명</h1>
    <p>요청된 블록은 C-LOOK 정책에 맞게 디스크 큐에 등록. 디스크 제어기가 쉬고 있으면 바로 제 어기에 명령을 전달함. 디스크 제어기로부터 완료 인터럽트 신호가 오면 완료된 요청을 큐에서 제거하고, 남은 요청들이 있으면 정책에 따라 다음 요청을 선택해 제어기에 명령을 전달함.</p>
    <h1>스케줄링 결과 비교</h1>
    <p>속도는 SSTF가 가장 유리, 기아문제 발생</p>
    <p>SCAN방식</p>
    <p>- SSTF보다는 시간이 더 소요되지만 기아 문제는 해결</p>
    <p>- 양 끝단의 실린더들은 상대적으로 실행 기회가 적음</p>
    <p>C-SCAN방식</p>
    <p>기회의 불균형을 해소하지만 SCAN에 비해서는 더 많은 시간 소비</p>
    <h1>디스크 입출력의 성능개선 방안</h1>
    <p>디스크 캐시</p>
    <p>- 디스크 읽기나 쓰기 작업 후에 그 내용을 커널 내부의 디스크 캐시 메모리에 보관</p>
    <p>- 이후 동일한 블록에 대한 읽기 작업이 요청되면 이 캐시의 내용을 그대로 사용함</p>
    <p>- 디스크 읽기 작업 횟수를 줄임</p>
    <p>지연 기록 방식</p>
    <p>- 쓰기 작업 요청 시 실제로 디스크 제어기에 쓰기 작업 명령을 보내지 말고</p>
    <p>- 커널 내부의 버퍼 메모리에만 보관</p>
    <p>- 이후 동일한 블록에 대한 쓰기 작업 요청 시 이전의 쓰기 데이터는 무의미하므로 새로운 데이터로 대치</p>
    <p>- 최종 내용에 대해서만 디스크 제어기에 쓰기 작업을 요쳥</p>
    <h1>지연기록 방식의 문제점</h1>
    <p>컴퓨터가 갑자기 꺼지면 파일 시스템의 데이터 일관성에 문제가 발생 </p>
    <p>유닉스와 같이 안정적인 시스템에서 입출력 성능을 중요시하는 운영체제에서 적용</p>
    <p>클러스터</p>
    <p>- 연속된 블록들의 그룹</p>
    <p>- 파일에 블록들을 할당할 떄 클러스터 단위로 할당</p>
    <p>-- 연결된 블록 할당 방식이나 인덱스 블록 할당 방식을 사용가능</p>
    <p>-- 가능한 한 인접한 블록들을 할당할 수 있도록 개선</p>
    <p>- 내부 단편화 문제</p>
    <p>-- 각 파일의 마지막 클러스터를 여러 파일들이 공유하여 블록 단위로 나누어 사용하도록 함으로써 해결</p>
    <p>조각모음</p>
    <p>- 파일들 간 또는 파일들과 빈 데이터 블록 목록 간에 블록들을 서로 교환</p>
    <p>- 쓰레기 수집</p>
    <p>-- 빈 블록들도 연속된 영역이 되어서 새로운 파일에 할당할 때 연속된 데이터 블록들이 차례대로 할당되도록 함 </p>
    <h1>플레시 메모리와 SSD</h1>
    <p>가볍고 속도 빠르고 전력 소모량 적고 외부의 충격에도 강함</p>
    <p>좀 비쌈</p>
    <p>플래시 메모리의 단점</p>
    <p>- 제자리에 덮어쓰기가 되지 않음</p>
    <p>- 이미 데이터가 기록되어 있는 부분에는 지우기 절차를 거쳐야만 쓰기가 가능</p>
    <p>해결방법</p>
    <p>- 플래시 메모리의 특성을 고려한 새로운 파일시스템 사용: 리누스의 JFFS, F2FS</p>
    <p>- 기존 파일 시스템을 그대로 사용하도록 저장장치만 SSD사용</p>
    <p>-- 대신 SSD내부에 플래시 변환 계층(FTL)을 두어 파일 시스템에서 요청한 논리적 위치 정보를 SSD 내부에서 실제로 저장한 위치 정보로 매핑하여 처리</p>
    <h1>SSD의 구성</h1>
    <p>하나의 SSD는 여러 개의 플래시 메모리 칩들로 구성</p>
    <p>하나의 칩은 블록들의 집합으로 구성</p>
    <p>각 블록은 페이지들의 집합으로 구성</p>
    <p>읽기와 쓰기는 페이지 단위로 처리</p>
    <p>지우기는 한 블록 단위로만 처리</p>
    <h1>플래시 변환 계층</h1>
    <p>FTL을 적용한 SSD는 파일 시스템에서는 페이지들의 집합으로 간주하고 페이지 단위로 읽기와 쓰기를 요청</p>
    <p>여기에 사용되는 논리적 페이지 번호를 SSD 내부에서 FTL에서는 실제로 기록된 물리적 페이지 번호로 변환하여 사용</p>
    <p>SSD 내부에는 전용 제어기가 있어서 FTL의 기능을 실행</p>
    <p>파일 시스템으로부터 논리적 페이지 번호 (LPN)로 지정된 특정 페이지의 쓰기 요청이 오면 FTL에서는 빈 페이지를 선택하여 기록하고 그 물리적 페이지 번호 (PPN)를 LPN과의 쌍으로 내부에 매핑 정보에 등록</p>
    <p>이 LPN 페이지에 대한 읽기 요청이 오면 매핑 정보로부터 대응되는 PPN을 찾아서 그 페이지의 내용을 읽음</p>
    <p>동일한 LPN에 새로운 쓰기 요청이 오면 다른 빈 페이지를 선택하여 기록하고 그 PPN으로 매핑 정보를 갱신</p>
    <h1>가비지 컬렉션과 웨어 레벨링</h1>
    <p>FTL의 기능에는 가비지 컬렉션과 웨어 레벨링 기능이 포함</p>
    <p>블록들에는 무효 페이지들과 유효 페이지들이 혼합</p>
    <p>일부 페이지만 유효한 블록들에 대해서는 새로운 블록에 유효한 페이지들만 복사한 후에 이전 블록들은 지워서 재활용하는 가비지 컬렉션 작업을 수행</p>
    <p>가능하면 전체 블록들에 골고루 쓰고 지우기가 이루어지도록 빈 페이지들을 적절히 배치하는 것이 중요</p>
    <h1>Trim 기능</h1>
    <p>SSD 자체로는 어떤 페이지가 계속 데이터를 보존해야 할지를 구별할 수가 없음</p>
    <p>SSD는 트림 요청을 받은 논리적 페이지들에 대해서는 바로 무효로 등록하고 가비지 컬렉션 작업에서 이 페이지들의 내용은 더 이상 보관하지 않는다.</p>
    <h1>데이터 일관성과 동기화</h1>
    <p>프로세스들 간에는 공유하고 있는 데이터에 대하여 그 내용을 변경하는 작업이 수시로 이루어 짐</p>
    <p>이 과정에서 데이터가 전혀 예상 밖의 내용으로 변경</p>
    <p>공유 데이터의 일관성이 유지되지 못한다고 함</p>
    <p>프로세스들 간에 실행 순서를 적절히 유지할 수 있는 동기화 필요</p>
    <p>공유 데이터를 수정하는 작업 중에는 동일한 공유 데이터를 수정하는 다른 프로세스로 문맥이 교환되지 않도록 막는 적절한 방안 필요</p>
    <h1>커널 데이터의 일관성 문제</h1>
<p>시스템 콜 함수 호출 중 커널 데이터를 수정하는 도중</p>
<p>문맥교환에 의해서 다른 프로세스로 변경되고 이 프로세스가 다시 시스템 콜 함수의 호출을 하게 되면 이제 커널의 데이터 수정 가능</p>
<p>일관성 깨짐</p>
<p>커널 데이터의 일관성 유지 문제는 인터럽트 처리 과정에서도 발생 </p>
<h1>크리티컬 섹션</h1> 
<p>프로세스들 간에 공유 데이터를 사용하는 코드 부분</p>
<h1>상호배제</h1>
<p>접근 중인 임의의 시점에서 하나의 프로세스만이 그 접근을 허용하도록 제어하는 것</p>
<p>쉽게 말해 그냥 한 놈만 그 프로세스 쓰는 거</p>
 <p>동일한 공유 데이터를 사용하는 크리티컬 섹션들 간에는 실행이 상호 배제 되어야 함</p>
 <p>크리티컬 섹션 부분 실행 전 적절한 허가를 얻는 entry 섹션 실행</p>
 <p>크리티컬 섹션 실행 후, 허가를 반납하는 부분인 exit 섹션 실행</p>
 <p>entry 섹션에서는 공유 변수와 관련된 다른 프로세스의 크리티컬 섹션이 실행 중에 있는 지를 검사하고, 만약 실행 중이라면 이것이 끝날 때까지 기다림</p>
<p>사용 중인지 여부는 적절한 표시 활용</p>
<p>exit 섹션에서는 사용 중이라는 표시를 해제하여 다른 프로세스가 공유 변수와 관련된 크리티컬 섹션을 실행할 수 있도록 함</p>
<h1>Entry/Exit 섹션의 조건</h1>
<p>상호배제</p>
<p>- 한 프로세스가 공유 데이터 S와 관련된 크리티컬 섹션을 실행중이면 다른 어떠한 프로세스도 S와 관련된 크리티컬 섹션을 실행해서는 안됨</p>
<p>진행</p>
<p>- S와 관련된 크리티컬 섹션을 아무도 실행중이지 않는 상태에서 실행하기를 원하는 프로세스들이 존재한다면 일정한 시간 내에 이들 중 하나는 크리티컬 섹션을 실행할 수 있어야 함</p>
<p>제한된 대기시간</p>
<p>- S와 관련된 크리티컬 섹션을 실행하려는 프로세스들은 일정한 시간 이내에 자신의 크리티컬 섹션을 실행할 수 있어야 함</p>
<h1>인터럽트 금지 - 문맥교환 방지</h1>
 <p>entry 섹션 부분에 인터럽트 금지 명령어를, exit 섹션 부분에 인터럽트 허용 명령어를 사용</p>
<p>크리티컬 섹션 실행 중 아예 다른 프로세스로 문맥 교환이 일어나지 않도록 처리</p>
<h1>인터럽트 금지 - 사용 제한</h1>
<p>크리티컬 섹션 실행 중 문맥 교환이 발생할 수 있는 시스템 콜 함수를 호출해서는 안되기 때문에 멀티프로세서 시스템에서는 이 방식을 적용 불가능</p>
<p>서로 다른 CPU에서 실행하는 프로세스들은 인터럽트 금지에 상관없이 언제든지 공유 데이터를 사용할 수 있음</p>
<p>인터럽트 금지 및 허용 명령어는 특권 명령어이므로 유저 모드에서는 실행 불가능, 커널 내에서만 사용 가능</p>
<p>크리티컬 섹션의 실행 시간이 길 경우 그만큼 인터럽트 금지 시간 길어짐</p>
<p>하드웨어의 인터럽트 처리 불가능</p>
<p>문맥 교환 자체가 금지되므로 해당 크리티컬 섹션과 전혀 상관없는 프로세스들도 실행 불가능</p>
<h1>인터럽트 금지 - 인터럽트 금지의 활용</h1>
<p>단일 프로세서 시스템에서만 적용 가능</p>
<p>시스템 모드에서 작동되는 커널 내부의 짧은 크리티컬 섹션을 위해선만 사용 가능</p>
<h1>스핀락 - 락 변수의 사용</h1>
<p>별도의 락 변수에 기록</p>
<p>entry 섹션에서는 락 변수를 1로 설정</p>
<p>이미 다른 프로세스가 이 값을 1로 설정한 상태이면 0으로 복구될 때까지 대기</p>
<p>exit 섹션에서는 락 변수 0으로 복구</p>
<h1>스핀락 - 특수 명령어의 활용</h1>
<p>락 변수 또한 하나의 공유 변수라는 것이 문제점임</p>
<p>entry에서 락 변수가 0인 것을 확인하고 1로 변경 직전 다른 프로세스로 전환되어 동일한 entry 섹션을 실행하는 경우</p>
<p>이 프로세스도 락 변수가 0인 것을 확인하고 바로 entry 섹션 통과</p>
<p>프로세스 둘 다 실행 n 상호 배제의 목적 달성 불가능</p>
<p>펜티엄 프로세서의 XCHG나 ARM 프로세서의 SWP 명령어 사용 n 지정된 레지스터의 내용과 메모리의 내용을 서로 교환</p>
<p>ex) XCHG(a, b) == exchange a, b</p>
<h1>스핀락 - 동작 시나리오 예</h1>
<p>락 변수가 0인 상태에서 여러 프로세스들이 entry 섹션 실행하려고 할 경우 가정 </p>
<p>가장 먼저 XCHG를 실행한 프로세스가 0을 읽어 entry 통과</p>
<p>이후에는 락 변수가 1이므로 무한 루프</p>
<p>다른 프로세스들이 무한 루프를 도는 동안 한 프로세스가 exit 섹션을 실행하면</p>
<p>락 변수가 0이 되므로 다음에 처음으로 XCHG를 실행하는 프로세스만 entry 통과</p>
<h1>스핀락 - 스핀락</h1>
<p>스핀락을 사용하기 위해서는 lock 변수를 위한 메모리 영역을 확보하고 spinLock, spinUnlock 함수를 호출</p>
<h1>스핀락 - 비지웨이팅</h1>
<p>특정한 조건이 만족될 때까지 기다리는 과정에서 쉬지 않고 조건을 계속 검사하면서 기다리는 것</p>
<p>프로세스 A가 락 변수를 1로 설정한 상태에서 중간에 프로세스 B로 전환되어 실행</p>
<p>그러면 이미 락 변수가 1이므로 프로세스 B는 비지웨이팅 상태</p>
<p>그 동안 프로세스 A는 실행기회가 없으므로 프로세스 B도 끝없이 비지웨이팅 상태 </p>
<p>만약, 라운드로빈을 사용중이면 먼 후에 락 변수가 0으로 복구</p>
<p>그 동안 비지웨이팅으로 시간 낭비</p>
<p>라운드로빈이 아니라면 끝없이 비지웨이팅 상태이고 CPU는 아무 작업도 못함</p>
<h1>스핀락 - 스핀락의 활용</h1>
<p>단일 프로세서 시스템에서는 부적합</p>
<p>멀티프로세서 시스템에서는 서로 다른 CPU에서 실행되는 프로세스들 간에 상호배제가 필요할 경우에 유용하게 사용 가능</p>
<p>짧은 크리티컬 섹션들에 유용하게 사용</p>
<p>사용자 프로세스에서 직접 사용할 수 있는 스핀락 기능은 제공하지 않음</p>
<h1>뮤텍스</h1>
<p>크리티컬 섹션을 위해 프로세스에서 직접 사용할 수 있도록 운영체제가 제공하는 기능 ,lock, unlock 함수 사용</p>
<p>비지 웨이팅 방식 없음</p>
<p>lock 함수에서 조건이 만족되지 않으면 호출한 프로세스를 waiting 상태로 전환</p>
<p>unlock 함수에서 waiting 상태의 프로세스들을 모두 깨워 주는 방식 사용</p>
<p>뮤텍스 함수는 커널에서 구현하고 시스템 콜 함수 형태로 제공 </p>
<p>보통 lock을 통과한 프로세스를 이 뮤텍스의 소유자로 기록</p>
<h1>세마포</h1>
<p>정수 값을 가지며 wait와 signal의 두 가지의 동작만 적용 가능한 객체로 정의</p>
<p>wait 동작에서는 현재의 정수 값이 양수가 될 때까지 기다렸다가 값을 1만큼 줄임</p>
<p>signal 동작에서는 정수 값을 1만큼 증가</p>
<p>세마포를 사용할때는 세마포의 초기 값을 1로 설정하고, entry 섹션에 wait, exit 섹션에 signal을 사용</p>
<p>비지웨이팅이 없도록 커널에 구현하고 시스템 콜 함수로 제공</p>
<h1>유한 버퍼 문제</h1>
<p>데이터를 생성하는 프로듀서 프로세스와 데이터를 소비하는 컨슈머 프로세스간에 한정된 공유 버퍼를 사용하는 문제</p>
<p>프로듀서는 빈 버퍼가 있을 때에 한애서 생성한 데이터를 버퍼에 저장</p>
<p>컨슈머는 버퍼에 저장된 데이터가 있을 때에 한해서 데이터를 버퍼에서 꺼내 사용</p>
<h1>Readers-Writers 문제</h1>
<p>일관성 유지에 있어서 상호배제 형태로만 처리하면 지나치게 사용을 제한하는 면이 있음 </p>
<p>reader들은 두 개 이상이 동시에 실행되어도 데이터의 일관성 유지에 문제 없음</p>
<p>하나의 reader가 크리티컬 섹션을 수행하고 있는 중에 또 다른 reader가 크리티컬 섹션을 실행하려고 할 때 이를 허용해주면 reader들이 불필요하게 대기하지 않아도 된다</p>
<p>값을 수정하지 않고 읽어 내기만 하는 프로세스들 간에는 동시에 크리티컬 섹션을 실행하도록 허용하는 방안이 있으면 불필요한 대기 시간을 줄일 수 있음</p>
<p>세마포를 이용하는 이유는 뮤텍스는 그 소유자만 해제할 수 있도록 구현된 시스템에서는 뮤텍스를 적용할 수 없음</p>
<p>Reader들 간에는 이 뮤텍스를 확보하는 reader와 해제하는 reader가 다를 수 있기 떄문</p>
<p>POSIX 표준에는 이러한 용도로 사용할 수 있는 readers-writers 락 함수를 정의</p>
<p>Writer들은 pthread_rwlock_wrlock을 사용</p>
<p>Reader들은 pthread_rwlock_rdlock을 사용 </p>
<p>해제를 위해서는 pthread_rwlock_unlock</p>
<p>생성을 위해서는 phtread_rwlock_init</p>
<h1>프로그래밍 언어 차원의 동기화 기능</h1>
 <p>여러 가지 실수가 발생 가능</p>
<p>이러한 것을 방지하고자 크리티컬 리젼과 모니터가 존재</p>
<p>이들은 운영체제에서 시스템 콜 함수 형태로 직접 제공하지 않더라도, 컴파일러가 세마포나 뮤텍스 등의 기능을 조합하여 적절한 코드를 자동으로 생성하도록 처리 가능</p>
<h1>크리티컬 리젼</h1>
<p>프로그래밍 언어에 shared와 region이라는 예약어 사용</p>
<p>shared T v;</p>
<p>region v when (B) S;</p>
<p>변수 형이 T인 변수 v는 프로세스들 간에 공유되는 변수, region 문에서만 사용 가능 </p>
<p>문장 S에서는 공유 변수인 v를 사용 가능</p>
<p>논리식 B가 참일 때만 실행</p>
<p>동일한 공유 변수를 사용하는 region들 간에는 상호 배제가 보장</p>
<p>B의 값이 거짓일 때에는 v에 대한 권한을 해제하고 B가 참으로 변경될 때까지 실행이 지연</p>
<p>B가 참으로 변경되면 다시 v에 대한 권한을 확보한 후 S를 실행</p>
<h1>모니터</h1>
<p>크리티컬 리젼과 마찬가지로 프로그래밍 언어 차원에서 제공하는 기능</p>
<p>공유 변수들은 모니터 속에서 선언되며 이 변수들은 모니터 속의 procedure들에서만 사용</p>
<p>한 프로세스가 특정 모니터의 procedure를 실행 중이면 다른 프로세스들은 이 모니터의 procedure들을 실행하지 못하고 대기 상태</p>
<p>이 procedure를 끝낸 시점에 대기 중이던 다른 프로세스들 중 하나가 선택</p>
<p>대기 중이던 특정 프로세스가 실행에 배제되어서는 안됨</p>
<h1>컨디션 변수</h1>
<p>condition 예약어에 의해 모니터 내에서 선언</p>
<p>procedure를 실행하던 프로세스가 실행에 필요한 조건이 만족되지 않으면 만족될 때까지 모니터 내에서 기다려야 하는 경우에 사용</p>
<p>모니터 외부에서 대기 중이던 다른 프로세스들 중에 하나가 선택되어 모니터 속의 procedure를 실행할 수 있음</p>
<p>x.wait()를 호출하면 이후에 다른 프로세스가 x.signal()을 호출할 때까지 무조건 대기</p>
<p>x.signal()을 호출하면 현재 x에 대기 중인 프로세스들 중에서 하나가 선택되어 실행을 재개</p>
<p>모니터는 한 프로세스가 wait 호출에 의해 대기 상태로 전환되면 이 모니터는 다른 프로세스가 procedure를 실행할 수 있도록 처리</p>
<p>모니터는 상호배제 조건을 만족해야 하므로 signal을 호출한 프로세스와 이 호출에 의해 실행을 재개하는 프로세스 중 하나만 실행되고, 이것이 모니터를 빠져나가는 시점에서 남은 프로세스가 실행</p>
<h1>컨디션 변수와 세마포의 비교</h1>
<p>세마포와 컨디션 변수에는 wait와 signal이라는 동일한 이름의 동작을 사용</p>
<p>세마포는 현재의 상태를 나타내는 값을 가지고 컨디션 변수에는 이런 값이 존재하지 않음</p>
<p>컨디션 변수의 wait에서는 현재의 값을 1만큼 줄이는 작업이 없고 무조건 대기 상태에 들어감</p>
<p>세마포의 signal은 현재의 값을 1만큼 증가시키지만 컨디션 변수에는 이런 작업이 없음  </p>
<h1>모니터의 구현</h1>
<p>모니터를 지원하는 컴파일러는 모니터와 컨디션 변수의 조건들이 만족되도록 뮤텍스나 세마포를 이용한 적절한 프로그램 코드로 대치</p>
<p>모니터마다 뮤텍스를 하나씩 사용하고 각 Procedure의 시작 부분에 이 뮤텍스를 확보하는 동작을 삽입하고 끝부분에는 이 뮤텍스를 해제하는 동작을 삽입</p>
<h1>Java의 모니터와 컨디션 변수</h1>
<p>모니터에서의 상호 배제 기능은 메소드 단위나 메소드 내의 일정한 부분에 synchronized를 선언하고, 동일한 객체의 synchronized 부분들 간에는 상호 배제가 보장된다</p>
<p>컨디션 변수는 객체마다 하나씩만 사용할 수 있으며 이름이 없이 wait(), notify()로 컨디션 변수의 wait와 signal 기능을 호출</p>
<h1>데드락</h1>
 <p>죽어 있는 잠김 상태 즉 전혀 풀릴 가능성이 없는 잠김 상태</p>
 <p>하나의 프로세스 집합이 데드락 상태</p>
  <p>이 집합의 모든 프로세스가 대기상태이고 이들이 기다리는 이벤트는 이 집합 속의 다른 프로세스에 의해서 발생해야 하는 경우</p>
  <h1>자원할당 그래프</h1>
<p>자원의 요청 및 할당에 대한 내용은 자원 할당 그래프로 표시 </p>
<p>프로세스는 원, 자원들은 사각형으로 표시</p>
<p>동일한 자원에 대하여 그 개수는 사각형 속에 점의 개수로 표시 l 에지</p>
<p>요구 에지</p>
<p>Pi->Rj는 Pi가 Rj를 요청한 상태</p>
<p>할당 에지</p>
<p>Rj->Pi는 Rj를 Pi에 할당한 상태</p>
<h1>데드락의 판단과 사이클</h1>
<p>사이클이 존재하지 않으면 데드락 X</p>
<p>사이클이 존재하고 사이클에 포함된 자원들은 한 개씩만 존재하면 데드락 발생 l 자원 당 여러 개가 존재할 경우 사이클이 존재하더라도 데드락이 아닐 수 있음</p>
<h1>데드락 방지 기법 - 데드락 발생 조건</h1>
<p>다음 조건 모두 만족할 때 발생  </p>
<p>데드락 방지 기법</p>
<p>이러한 발생 조건 중 하나라도 만족하지 않도록 하는 것</p>
<p>상호 배제</p>
<p>특정 자원은 특정 시점에 오직 한 개의 프로세스만 사용할 수 있음</p>
<p>선점 불가</p>
<p>자원은 선점하여 사용할 수 없고 먼저 확보한 프로세스가 스스로 해제해야만 다른 프로세스가 사용 가능</p>
<p>보유 및 대기</p>
<p>최소한 하나의 자원을 확보하고 있으면서 다른 프로세스들이 확보한 자원을 추가로 확보하기 위해 기다리는 프로세스가 존재</p>
<p>원형 대기</p>
<p>P1은 P2가 확보한 자원을 기다리고, P2는 P3이 확보한 자원을 기다리고 Pn은 P1이 확보한 자원을 기다리는 형태의 원형 대기 상태가 존재</p>
<h1>데드락 방지 기법 - 상호 배제와 선점 불가 조건</h1>
 <p>상호 배제 조건</p>
<p>자원들을 특정 시점에 두 개 이상의 프로세스들이 사용할 수 있도록 함</p>
<p>현실적으로 거의 불가능</p>
<p>선점 불가 조건</p>
<p>CPU 내부의 레지스터들이나 메모리 공간처럼 현재의 상태를 기록해 두었다가 차후 에 원래 상태로 복구가 가능한 자원들에 한정</p>
<p>자원의 특성상 선점이 가능하도록 변경하기 곤란</p>
<h1>데드락 방지 기법 - 보유 및 대기 </h1>
<p>기 확보 자원의 반납</p>
<p>일부를 확보한 상태에서 다른 자원을 확보하려고 했을 때 이것이 사용가능하지 않으 면 이전에 확보한 자원들도 모두 해제했다가 나중에 다시 확보</p>
<p>자원의 특성상 이미 확보하여 사용 중이던 자원을 작업을 완료하기 전에 해제하는 것이 불가능하거나 매우 어려움</p>
<p>일괄 확보</p>
<p>프로세스들이 여러 개의 자원을 사용해야 할 경우</p>
<p>필요한 모든 자원들이 사용 가능할 때까지 기다렸다가 한꺼번에 확보한 후에 필요한 순서대로 사용하고 해제</p>

 <p>데드락 방지에는 효과적</p>
 <p>당장 사용하지 않을 자원들까지도 미리 확보해 둠으로써 자원을 효율적으로 사용하지 못함</p>
 <p>기아 문제 초래</p>
 <h1>데드락 방지 기법 - 자원들의 확보 순서 고정</h1>
<p>원형 대기 방지</p>
<p>자원들에 대해 요청 순서를 사이클이 없도록 고정하여 정해 놓고</p>
<p>프로세스들은 항상 이 순서에 따라 자원들을 요청</p>
<p>보유 및 대기를 피하기 위해서 필요한 자원을 모두 미리 확보해 두는 방식에 비해서는 자원의 활용률을 높일 수 있음 </p>
<h1>데드락 회피 기법 - 데드락 회피</h1>
<p>데드락 방지 기법에서는 당장 필요하지 않은 자원들도 미리 확보해 두므로 자원의 활용률을 저하시키는 결과 초래</p>
<p>자원의 활용률을 높일 수 있는 방식</p>
<p>자원을 필요한 시점에 가서 요청</p>
<p>자원을 할당할 때, 할당의 결과로서 데드락이 발생할 가능성이 전혀 없으면 그대로 할당</p>
 <p>데드락의 가능성이 있으면 할당을 보류</p>
 <h1>데드락 회피 기법 - 데드락 가능성 검사</h1>
<p>각 프로세스들이 향후 어떠한 순서로 자원들을 요청할 지에 대한 정보가 필요</p>
<p>데드락이 발생하지 않을 것이라고 보장할 수 없다면 할당을 보류하고 요청한 프로세스는 대기 상태로 전환</p>
<h1>데드락 회피 기법 - 사용할 자원의 사전 통보</h1>
<p>프로세스들이 향후 어떤 자원들을 어떤 순서로 요청할 지에 대한 정보를 운영체제가 미리 알고 있어야 한다는 문제점</p>
<p>향후 사용할 자원들의 목록을 미리 운영체제에 알려주고 시작</p>
<h1>데드락 회피 기법 - 데드락 가능성 검사 방법</h1>
<p>자원 할당 그래프에 클레임 에지를 추가</p>
<h1>데드락 회피 기법 - 은행원 알고리즘</h1>
<p>자원 당 한 개씩만 있을 경우를 확장해서 동일한 자원이 여러 개 있을 경우에도 적용할수 있도록 만들어진 알고리즘</p>
<p>단순히 사이클의 존재 여부만으로는 데드락의 가능성 여부를 확인할 수 없고, 앞으로의 가능한 시나리오들을 전부 검사</p>
<h1>데드락 회피 기법 - 장단점</h1>
<p>자원의 활용률을 일정 부분 향상</p>
<p>자원 할당을 요청받을때 마다 데드락 발생 가능성을 검사해야 하므로 이로 인한 오버헤드 증가</p>
<p>데드락의 방생 가능성이 있다고 하더라도 실제로 발생하지 않을 수 있으므로 자원을 충분히 활용하지는 못함</p>
<h1>데드락 탐지 및 복구 기법 - 데드락 탐지 및 복구</h1>
<p>데드락 회피 깆법은 실제로 할당 가능한 자원도 앞으로의 데드락 발생 가능성 때문에 할당을 보류할 수 있고, 자원의 활용률은 여전히 제한</p>
<p>데드락 탐지 및 복구 기법은 현재의 상태에 대한 정보만 사용하여 요청한 자원이 사용가능하기만 하면 무조건 할당</p>
<p>데드락의 발생 여부는 적절한 시점마다 검사를 실시하고, 만약 데드락이 발견되면 적절한 방법으로 복구해야 함</p>
<h1>데드락 탐지 및 복구 기법 - 적용 제한</h1>
<p>데드락 상태를 확인하면, 이를 복구하는 과정</p>
<p>자원들을 할당하기 이전 상태로 되돌리거나 자원을 할당받은 프로세스들을 강제로 종료</p>
<h1>데드락 탐지 및 복구 기법 - 데드락의 검사 </h1>
<p>각 자원 당 한 개씩만 있는 경우</p>
<p>데드락 발생 여부의 검사는 자원 할당 그래프에서 사이클이 존재하는지 여부의 검사 로 처리</p>
<p>클레임 에지 없이 원래의 자원 할당 그래프 그대로 적용</p>
<p>자원 당 여러 개가 존재할 경우</p>
<p>은행원 알고리즘</p>
<h1>데드락 탐지 및 복구 기법 - 데드락 검사 시점</h1>
 <p>프로세스들이 요청한 자원을 할당할 수 없을 때마다 실행</p>
<p>너무 자주 검사를 실행하는 데 따른 오버헤드 증가</p>
<p>주기적으로 한 번씩 실행하거나 CPU의 활용률이 낮은 시점에 실행</p>
<p>검사하는 간격이 클수록 실제 데드락이 발생했을 경우에 데드락에 연루된 프로세스 들이 많은 시간을 허비하는 결과를 초래</p>
<p>시간이 흐를수록 더 많은 프로세스들이 이 데드락 상태에 연루</p>
<h1>데드락 탐지 및 복구 기법 - 데드락 검사 주체 </h1>
<p>커널이 직접 담당</p>
<p>요청한 자원을 할당할 수 없을 때 즉시 검사하기 위해서</p>
 <p>별도의 커널모드 프로세스를 두어서 검사를 전담</p>
<p>일정한 주기마다 검사하거나 CPU의 활용률이 낮은 시점에 검사</p>
<h1>데드락 탐지 및 복구 기법 - 롤백으로 데드락 복구</h1>
<p>데드락에 연루된 프로세스들을 데드락이 발생하기 이전 상태로 롤백 시킨 후 데드락이 발생하지 않는 방향으로 다시 실행</p>
<p>롤백을 수행하기 위해서는 주기적으로 또는 자원을 할당할 때마다 프로세스들과 자원들 의 모든 상태를 기록해야 함</p>
<p>이러한 시점들을 체크포인트라고 함</p>
<p>자원에 따라서는 롤백이 불가능하거나, 기록해야 할 정보의 양이 방대하며, 하나의 자원 을 복구하면 이로 인해 다른 자원들을 차례로 복구해야 하는 도미노 현상 발생</p>
<p>실제 시스템에 적용하기가 상당히 어려움</p>
<h1>데드락 탐지 및 복구 기법 - 프로세스 강제종료로 데드락 복구</h1>
<p>데드락에 연루된 프로세스들의 전부 또는 일부를 강제로 종료시키고 이들이 사용 중이던 자원들을 해제하는 방법 </p>
<p>적용 가능한 선택 기준</p>
 <p>프로세스의 우선 순위, 이미 실행한 시간, 앞으로 실행할 시간, 이미 사용한 자원의 양, 앞으로 사용할 자원의 양, 대화형인지 아닌지 여부, 또는 종료시켜야 하는 프로 세스 개수의 최소화 등</p>
 <p>프로세스별로 어느 정도 진행된 상태에서 강제로 종료될 경우 발생할 수 있는 문제들에 대한 철저한 검증 필요</p>
 <h1>IPC (프로세스 간의 통신)</h1>
<p>프로세스들은 실행 과정에서 서로 간에 데이터를 주고 받음</p>
<p>클라이언트 프로세스와 서버 프로레스 간에 요구 내용을 전달하고 그 결과를 반송</p>
<p>프로세스들이 병행하여 실행 하면서 서로 간에 필요한 데이터를 교환</p>
<p>IPC를 위해서는 공유 메모리 방식이나 메시지 전달 방식을 사용</p>
<h1>공유메모리</h1>
<p>송신측과 수신측이 일정한 메모리 영역을 공유하고, 송신측이 여기에 전송하고자 하는 내용을 기록하면 수신측은 여기서 내용을 읽어 간다</p>
<h1>송수신 동기화</h1>
<p>수신측은 공유 메모리의 내용을 읽어 내기 위해서 송신측이 송신 내용을 기록했는지 여부를 확인할 수 있어야 하고</p>
<p>송신측은 공유 메모리에 새로 전송할 내용을 기록하기 위해서 이전에 기록한 내용을 수신측이 읽어 갔는지 여부를 확인해야 함</p>
<h1>메시지 전달</h1>
<p>운영체제가 커널 내부에 메시지를 기록할 수 있는 공간을 마련</p>
<p>프로세스들은 적절한 시스템 콜 함수를 통하여 메시지의 송신이나 수신을 운영체제에게 요청할 수 있도록 함</p>
<p>프로세스들 간에 메모리를 공유해야 할 필요가 없고</p>
<p>운영체제가 중간에서 메시지를 보관했다가 대신 전달하는 형식을 사용</p>
<h1>송수신 동기화</h1>
<p>송신자와 수신자 간의 동기화 문제는 메시지 보관 장소에 기록하는 과정과 읽어 내는 과정에서 운영체제가 처리</p>
<p>메일박스가 대표적</p>
<p>운영체제는 보관 장소가 가득 찬 상태에서 송신측이 전송하고자 할 때 이를 대기 상태로 전환시키고</p>
<p>보관된 메시지가 없는 상태에서 수신측이 메시지를 수신하려고 할 때에도 이를 대기 상태로 전환</p>
<h1>장단점 비교</h1>
<p>공유메모리 방식</p>
<p>송신자의 공유메모리 쓰기 한 번과 수신자의 공유메모리 읽기 한 번이 필요</p>
<p>대량의 데이터를 고속으로 전달하는데 유용 </p>
<p>메시지 전달 방식</p>
<p>송신자가 메시지 버퍼에 쓰기, 운영체제가 커널 메시지 버퍼로 복사, 운영체제가 수 신자 메시지 버퍼로 복사, 수신자가 수신 메시지 버퍼 내용 사용 등의 과정을 거치 므로 많은 오버헤드가 수반</p>
<p>동기화 문제를 별도로 고려하지 않아도 ᄀᄎ</p>
 <p>메시지의 양이 많지 않을 때 유용</p>
 <h1>유한버퍼 문제</h1>
<p>데이터를 송수신하는 과정에서 필요한 동기화 문제를 두 개의 세마포 Full과 Empty로 처리</p>
<p>공유메모리는 순환버퍼로 처리</p>
<h1>스레드간의 공유메모리</h1>
<p>하나의 프로세스에 소속된 스레드들은 하나의 논리적 주소공간을 가지며 하나의 페이지 테이블을 공유</p>
<p>동일한 프로세스에 소속된 스레드들 간에는 전역변수 영역의 모든 메모리는 서로 공유하므로 공유메모리의 설정이 단순히 전역변수를 선언하는 것으로 충분</p>
<h1>프로세스간의 공유메모리</h1>
 <p>서로 다른 프로세스 간에는 공유메모리 설정을 위한 별도의 절차가 필요</p>
<p>공유메모리 영역을 생성하고 이것을 프로세스별로 자신의 논리적 주소공간의 적절한 주소로 매핑하는 절차를 거침</p>
<h1>공유메모리의 구현</h1>
<p>공유메모리 기능의 구현은 논리적 주소 영역의 할당과 페이지 테이블의 설정으로 처리</p>
<p>일정한 크기의 공유메모리에 대한 주소 매핑 요청이 들어오면 이 프로세스의 가용 논리적 주소 공간을 찾아서 페이지 테이블에 공유메모리 영역의 물리적 주소를 적절히 기록하는 것으로 처리</p>
 <p>공유메모리의 제거는 페이지 테이블에 할당된 주소공간을 잘못된 주소 영역으로 기록하는 것으로 처리</p>
 <h1>파일 매핑</h1>
<p>프로세스들 간에 공유메모리와 동일한 용도로 사용</p>
<p>파일에 대한 입출력을 일반적인 메모리 영역을 읽고 쓰는 것으로 처리할 수 있도록 하는 기능</p>
<p>프로세스들 간에 동일한 파일을 자신의 논리적 주소공간에 매핑하고 이 영역에 메모리 읽기나 쓰기를 하면 공유메모리를 설정한 것과 동일한 효과</p>
<h1>메일박스</h1>
<p>전송하고자 하는 프로세스가 메시지를 지정된 메일박스에 넣어 두면 수신하고자 하는 프로세스는 이 메일 박스에서 메시지를 꺼내 가는 형식을 취함</p>
<p>보통 저장할 수 있는 용량 제한</p>
<p>동기화 문제는 운영체제에서 처리</p>
<p>각 메일박스는 고유한 식별자를 가짐</p>
<p>운영체제에서는 메시지 전송을 위한 함수와 메시지 수신을 위한 함수를 제공</p>
<h1>랑데부</h1>
<p>메일박스는 일정한 용량의 메시지 버퍼를 제공하고 적절하게 동기화를 처리해 줌</p>
<p>랑데부는 극단적으로 버퍼의 용량이 0인 형태로 구현된 메시지 통신 기능을 지칭</p>
 <p>송신과 수신이 모두 요청된 시점에 운영체제는 메시지를 바로 송신 프로세스의 영역에서 수신 프로세스 영역으로 복사</p>
  <p>송신자와 수신자가 직접 만나야 실제 전송이 이루어 짐</p>
<p>송신이든 수신이든 먼저 요청한 프로세스는 상대방도 요청할 때까지 대기상태로 전환</p>
<h1>파이프/FIFO/소켓</h1>
<p>유닉스의 파이프나 FIFO, 스트림 소켓 등은 송신자가 메시지 간의 구별이 없이 보낸 바이트 스트림을 수신자가 순차적으로 수신</p>
<p>송신자는 임의의 양 만큼씩을 전송</p>
<p>커널은 메시지 내용을 모아서 저장</p>
<p>수신자는 필요한 양 만큼씩을 수신하여 사용</p>
<h1>유닉스의 구현</h1>
<p>송수신은 파일의 read/write와 동일하게 처리</p>
<p>송신을 위해서는 write 함수를 사용하여 필요한 바이트 수만큼을 전송 </p>
<p>수신을 위해서는 read 함수를 사용하여 필요한 바이트 수만큼만 수신</p>

<h1>메일박스를 이용한 다자간 통신</h1>
<p>메일박스의 장점은 다자간 통신이 간편</p>
<p>다수의 클라이언트랑 뚜시뚜시할 떄 하나의 메일박스를 통해 간편하게 목적 달성</p>
<p>서버 프로세스는 지정된 메일박스에서 수신을 기다리고</p>
<p>모든 클라이언트 프로세스들은 서비스 요청 내용을 담은 메시지를 이 메일박스에 전송</p>
<p>반송 메시지는 각 클라이언트들에게 별도로 전달해야 하므로 별도의 일대일 통신 방식을 사용</p>
<h1>공유메모리를 이용한 방송</h1>
 <p>공유메모리는 여러 수신자들에게 동일한 메시지를 방송으로 전달하는데 효율적 </p>
 <p>통신에 참가하는 프로세스들은 모두 동일한 메모리를 공유하고</p>
<p>송신자는 이 공유메모리에 한 번 기록하는 것으로 전송이 끝남</p>
<p>수신자는 각각 이 공유메모리의 내용을 읽어 나감</p>
<h1>동기식과 비동기식</h1>
<p>비동기식</p>
<p>전송 요청을 받으면 커널 내부에 그 내용을 보관하고 송신 프로세스는 계속 실행할 수 있도록 하는 방식을 비동기식 </p>
<p>picoKernel의 메일박스</p>
<p>동기식</p>
<p>송신 프로세스를 대기 상태로 전환시켰다가 요청된 메시지가 실제 수신 프로세스에게 전달된 시점에 송신 프로세스를 실행 가능 상태로 전환하는 방식</p>
<p>랑데부</p>
<p>송신 프로세스는 응답 메시지를 기다리고, 수신 프로세스가 응답 메시지를 반송한 시점에 송신 프로세스가 실행 가능 상태로 전환하는 방식</p>
<p>원격 프로시저 호출</p>
<h1>직접과 간접</h1>
<p>직접 통신 방식</p>
<p>수신할 프로세스의 번호를 직접 지정하여 전송하는 방식</p>
<p>유닉스의 시그널</p>
 <p>간접 통신 방식</p>
<p>수신 측 프로세스의 번호 대신 별도의 메시지 보관 장소를 지정하는 방식 </p>
 <p>picoKernel의 메일박스와 랑데부</p>
 <p>유닉스의 파이프, FIFO, 스트림소켓</p>
<h1>네이밍</h1>
<p>메시지의 송수신을 위해 상대방을 지정하는 방안</p>
 <p>프로세스 번호가 동적으로 할당되는 경우도 있기 때문에 네이밍을 위한 별도의 방안 필요</p>
  <p>별도로 지정된 고유한 이름을 사용 </p>
   <p>유닉스의 소켓</p>
<p>공개된 고유 포트 범호를 설정할 수 있는 기능 제공</p>
 <p>유닉스의 FIFO와 파일 매핑</p>
<p>파일 시스템 상에 이름이 등록되어 있고 이것은 open 하여 사용하는 방법 사용 </p>
<p>유닉스의 System V IPC 함수</p>
 <p>세마포나 메시지 큐, 공유메모리의 번호를 알아내기 위해서 파일 이름과 별도로 지정한 번호를 조합한 키 값을 사용</p>
<h1>단방향과 양방향</h1>
 <p>단방향 통신</p>
 <p>통신 채널에 송신측과 수신측이 고정</p>
 <p>랑데부 </p>
  <p>양방향 통신</p>
<p>양측 모두 송신과 수신을 할 수 있음</p>
 <p>메일박스</p>
  <p>유닉스의 소켓이나 FIFO</p>
  <h1>데이터의 양과 편리성</h1>
 <p>한꺼번에 전달할 데이터의 양이 많을 경우에는 메시지 전달 방식보다 공유 메모리를 사용하는 것이 메모리를 복사하는 작업과 운영체제에 시스템 콜 함수를 호출하는 횟수를 줄일 수 있어서 효율적</p>
 <p>메시지 전달 방식은 공유 메모리 방식보다 개발하기에는 편리</p>
 <h1>멀티프로세서와 MPP</h1>
<p>초창기에는 하나의 CPU를 사용하는 단일 프로세서 시스템 </p>
<p>이후 멀티프로세서 시스템 보편화</p>
<p>프로세스들을 각 CPU에 골고루 분배하여 실행</p>
 <p>대규모 병렬처리 개발</p>
<p>수십 내지 수천 개의 CPU들이 하나의 작업을 분담하여 처리</p>
<h1>컴퓨터 클러스터</h1>
 <p>통신망으로 연결된 단위 컴퓨터 간에 작업을 적절히 배분하여 처리하는 기능과 분산 파일 시스템이 중요</p>
<p>그리드 컴퓨팅</p>
<p>전 지구 상의 컴퓨터들이 인터넷으로 연결되어 함께 작업을 진행 할 수 있음</p>
<h1>운영체제가 없는 시스템</h1>
 <p>하드웨어와 관련된 모든 부분을 프로그램상에 포함시키고 이를 적절한 방법으로 메모리에 적재시켜 실행</p>
 <h1>단순일괄처리 시스템</h1>
 <p>프로그램을 작성하고, 프로그램을 입력하고, 컴파일 및 어셈블 작업을 실시한 후, 이를 실행시키고 결과를 출력한다.</p>
<p>이러한 절차를 자동화시킨것이 단순일괄처리 시스템</p>
<p>느린 속도의 입출력 장치 때문에 CPU가 많은 시간을 대기함</p>
<p>속도가 나름 빠른 자기 테이프를 사용하는 오프라인 입출력 장치를 도입</p>
 <p>고가의 컴퓨터 한 대에 여러 대의 저렴한 입력 시스템들과 출력 시스템들을 결합하여 사용하면 컴퓨터의 CPU가 대기하는 시간을 단축</p>
 <h1>스풀링 시스템</h1>
 <p>오프라인 입출력 시스템을 사용하는 대신 CPU의 실행 시간과 입출력 작업 시간이 중첩되도록 처리하는 방식 사용</p>
 <p>하나의 작업이 실행되고 있는 동안에 다음 작업을 위해 카드 판독기로부터 읽어 들이고 이전에 완료된 작업의 결과를 라인프린터로 출력하는 작업을 병행</p>
 <h1>하드디스크의 활용</h1>
<p>스풀링은 임의 위치 접근이 가능하고 입출력 속도가 빠른 하드디스크가 개발되어 활용되면서 가능해짐</p>
<p>카드 판독기로부터 읽어 들인 내용과 라인프린터로 출력할 내용들은 하드디스크에 임시로 저장</p>
<p>실제 입력과 출력 작업은 프로그램의 실행 중간에 입출력기의 속도에 맞추어서 수시로 실행</p>
<p>하드디스크로의 입출력 작업은 카드판독기, 라인프린터 및 자기 테이프 드라이브보다 훨씬 고속으로 실행이 가능하므로, CPU는 입력 작업이나 출력 작업을 위한 긴 시간 동안 대기할 필요가 없고 따라서 CPU의 활용률을 높일 수 있음</p>
<h1>멀티프로그래밍 시스템</h1>
<p>스풀링 시스템에서 디스크에는 여러 개의 작업들이 대기 상태에 있을 수 있음</p>
<p>그러나 메모리에는 오직 한 개의 프로그램만 적재된 상태로 실행</p>
<p>멀티프로그래밍 시스템에서는 메모리상에 여러 개의 프로그램들을 동시에 적재해 두고 적절한 것을 선택하여 실행할 수 있도록 해줌</p>
 <p>디스크를 활용한 스풀링 작업이 필요가 없음</p>
<p>디스크 입출력 자체를 위한 대기 시간에도 다른 프로그램을 실행 가능</p>
<h1>스케줄링의 필요성</h1>
<p>입출력과 계산 작업을 위한 프로그램들이 적절한 비율로 메모리에 동시에 적재되어 있으면, CPU를 충분히 활용 가능</p>
<p>잡 스케줄링과 CPU 스케줄링이 모두 필요</p>

<h1>시분할 시스템</h1>
 <p>멀티 프로그래밍 시스템을 사용자 입장에서 대화형으로 작업을 실행할 수 있도록 발전한 것</p>
 <h1>온라인 터미널의 활용</h1>
<p>터미널의 개발 덕분에 시분할 시스템 가능</p>
<p>사용자는 화면상에 출력된 내용을 보면서 필요한 입력 데이터를 키보드를 통해 수시로 입력할 수 있는 대화형 작업 환경 가능</p>
<h1>시분할 스케줄링 정책의 필요성</h1>
<p>대화형 사용자들에게는 응답시간이 중요하므로 시분할 방식의 스케줄링이 필요</p>
<h1>사용자 인터페이스</h1>
<p>멀티프로그래밍 시스템까지는 오프라인</p>
<p>시분할 시스템에서는 터미널을 통하여 온라인으로 사용</p>
<p>프로그램이나 데이터를 디스크에 체계적으로 보관해야 하므로 온라인으로 사용할 수 있 는 파일시스템이 운영체제에 추가</p>
<p>여러 사용자들이 각자 자신의 파일들을 관리</p>
<p>파일들을 사용자별로 보호할 수 있는 기능 추가</p>
 <p>입력을 위한 카드 판독기는 필요 없음</p>
<p>프린터의 출력 순서를 적절하게 조정해주는 기능 추가</p>

<h1>멀티프로세서 시스템</h1>
<p>프로세스들을 CPU들에 적절히 할당하여 실행하도록 해야함</p>
<p>서로 다른 CPU에서 실행되는 프로세스들 간의 동기화나 통신 기능도 필요</p>

<h1>병렬처리 시스템</h1>
 <p>많은 수의 CPU들을 사용하며 하나의 프로세스가 여러 개의 작은 부분들로 분할되어 여러 개의 CPU들에서 동시에 실행</p>
<p>보통 사용자와의 입출력과 CPU 할당을 전담하는 전위 프로세서와 할당 받은 작업을 실행하긴만 하는 후위 프로세서들로 구분</p>
<p>이에 비해 멀티프로세서 시스템은 각 CPU에 동일한 운영체제 코드가 실행되고 각 CPU는 동일한 자격으로 작업을 실행</p>
<h1>분산처리 시스템</h1>
<p>멀티프로세서와 병렬처리 시스템은 CPU들이 동일한 장소에 설치되어 있고 메모리를 공유</p>
 <p>분산처리 시스템은 독립적인 시스템들이 통신망으로 상호 연결된 형태로 구성되고 메모리를 공유하지 않음</p>
 <p>단순한 분산 운영체제</p>
<p>분산 시스템을 구성하는 단위 컴퓨터들 간에 파일을 공유할 수 있는 기능만을 제공하여 전체를 하나의 파일 시스템처럼 사용할 수 있게 함 </p>
<p>완전한 분산 운영체제</p>
<p>프로세스들을 상대적으로 부하가 적은 노드를 찾아 할당할 수 있는 기능과 실행 중이던 프로세스도 필요에 따라서는 부하가 작은 노드로 이동할 수 있는 기능제공</p>

<h1>현재의 운영체제</h1>
<p>네트워크 파일시스템 제공</p>
 <p>유닉스 계열의 NFS</p>
<p>윈도우의 파일공유 기능</p>
<h1>실시간 시스템</h1>
 <p>센서로부터의 입력 데이터를 적절히 처리하고 그 결과에 따라 적절히 제어 동작을 실시해야 하는 시스템의 경우는 센서의 입력 시점으로부터 적절한 제어가 완료될 때까지의 시간은 적절한 한도 내에서 제한</p>
 <h1>실시간 스케줄링</h1>
 <p>스케줄링은 각 프로세스의 작업 마감 시간으로 고려해야 함</p>
 <p>주기가 짧은 것들을 먼저 실행</p>
 <p>우선순위 스케줄링을 지원하는 운영체제에서 주기가 짧은 프로세스에 높은 우선순위를 부여</p>
  <p>실시간 프로세스들 간에는 우선순위 스케줄링을 적용</p>
  <p>동일한 우선순위의 프로세스들간에는 FCFS나 라운드로빈 적용</p>

<h1>실시간 운영체제</h1>
<p>인터럽트 지연시간을 제한하기 위해서는 선점형 스케줄링의 지원과 선점형 커널이 요구 </p>
<p>파일 시스템도 연속된 블록을 할당하는 형태를 사용함으로써 실시간 프로세스가 연속적으로 파일을 사용할 때 실행속도를 높임</p>

<h1>내장형 시스템</h1>
<p>특정 목적의 시스템속에 구성물로서 포함되어 동작하는 컴퓨터 시스템</p>
 <p>일반적으로 디스크가 사용되지 않고 대신 ROM이나 플래시메모리를 사용 </p>
 <p>메모리의 용량이 제한</p>
 <p>CPU의 성능도 비교적 낮음</p>
</body>
</html>
